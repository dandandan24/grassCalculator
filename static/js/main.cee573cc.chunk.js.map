{"version":3,"sources":["Components/CalcWindow/RollsTable.js","Components/CalcWindow/explain.PNG","Components/Konva/Rectangle.js","Components/Konva/Circle.js","Components/Konva/Polygon.js","Components/CalcWindow/CalcWindow.js","Components/Konva/DrawToolBar.js","Components/Konva/KonvaContainer.js","Components/Konva/copiedPolygon.js","Algorithm/ShapeSplitter.js","Algorithm/SmallestRectangle.js","Algorithm/LongestStraightLinePossible.js","Algorithm/RectangleSplitter.js","Algorithm/RectangleMeasures.js","Algorithm/Algorithm.js","Algorithm/ShapesProportions.js","Components/container.js","App.js","reportWebVitals.js","redux/konvaReducer.js","redux/rootreducer.js","redux/store.js","index.js"],"names":["RollsTable","props","TableContainer","component","Paper","Table","TableHead","TableRow","TableCell","align","TableBody","row","TwoMeter","ThreeMeter","FourMeter","Math","floor","TotalArea","LeftOvers","Rectangle","shapeProps","isSelected","onSelect","onChange","shapeRef","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onClick","onTap","ref","draggable","onDragEnd","e","x","target","y","onTransform","node","scaleX","scaleY","width","max","height","onTransformEnd","boundBoxFunc","oldBox","newBox","Circular","connect","state","proportion","konva","accuracy","dispatch","useState","points","setpoints","curMousePos","setcurMousePos","isMouseOverStartPoint","setisMouseOverStartPoint","isFinished","setisFinished","getMousePos","stage","getPointerPosition","handleMouseOverStartPoint","event","length","scale","handleMouseOutStartPoint","handleDragStartPoint","console","log","handleDragMovePoint","index","pos","attrs","slice","handleDragEndPoint","flattenedPoints","concat","reduce","a","b","onMouseDown","mousePos","onMouseMove","stroke","strokeWidth","closed","map","point","startPointAttr","hitStrokeWidth","onMouseOver","onMouseOut","fill","onDragStart","onDragMove","radius","enabledAnchors","useStyles","makeStyles","theme","root","breakpoints","down","up","Polygons","Rectangles","Circles","mode","Windowstage","AlgorithmResult","ChangeMode","newMode","type","ChangeStageWindow","newWindowstage","UpdateCircles","newCircles","UpdatePolygons","newPolygons","UpdateRectangles","newRectangles","classes","currentTab","setCurrentTab","document","getElementById","Outerdiv","setOuterdiv","currentShowTab","setcurrentShowTab","orderPoints","Points","orderedpoints","push","PitagorasSentence","x1","y1","sqrt","pow","abs","BuildStripesString","counterArray","Stripes","toString","numofSquaresWidth","offsetWidth","SquarelinesWidth","i","finalResults","remain","Arrayshapes","shape","SumUpOrder","totalArea","SumArea","Dialog","fullScreen","maxWidth","onClose","close","open","Grid","container","spacing","style","direction","item","xl","xs","fontSize","marginRight","Divider","variant","position","right","marginTop","Button","textTransform","color","className","Tabs","value","indicatorColor","textColor","newValue","Tab","label","toFixed","id","border","borderRadius","offsetHeight","number","rect","text","xDirection","circle","poly","anchorPoints","sceneFunc","context","beginPath","moveTo","quadraticCurveTo","fillStrokeShape","parseFloat","allRects","coreWidth","remainArea","coreHeight","Width","Height","X","Y","dash","Undo","Reset","ChangeProportion","newProportion","ChangeAccuracy","newAccuracy","md","alignItems","boxShadow","margin","ToggleButtonGroup","size","exclusive","ToggleButton","TextField","defaultValue","InputLabelProps","shrink","Typography","marginBottom","gutterBottom","Slider","getAriaValueText","valuetext","aria-labelledby","valueLabelDisplay","step","marks","min","Component","stateStack","ChangeHeight","newHeight","ChangeStage","newStage","actionTrigger","AddPoint","Point","newPoint","emptyPoints","currentLine","setCurrentLine","currentRect","setCurrentRect","lines","setLines","selectedId","selectShape","DraggedPolygon","setDraggedPolygon","DraggedPoint","setDraggedPoint","currentCircle","setCurrentCircle","selectedcircleId","setSelectedcircleId","startPoint","endPoint","curvePoint","DraggedAnchor","setDraggedAnchor","proportionConst","polygon","anchor","flattenddots","dots","anchorDots","CopyPolygons","window","onkeypress","keyCode","getStage","checkDeselect","x0","y0","j","checkIfTouchPoly","anchorpoints","pixelLength","CmLength","source","slope","EquatePoint","Infinity","dx","dy","FindPoint","calculateSlope","diffrenceX","diffrenceY","onMouseUp","yDirection","line","newAttrs","lineCap","opacity","LineEquation","indexOfPoint","removeUselessPoints","PolygonPoints","beforePointEquation","afterPointEquation","PointsToSplice","CopyPoints","Set","splice","ShapeSplitter","StartPoint","EndPoint","OriginShapePoints","StartIndex","EndIndex","FirstShape","SecondShape","tranformToTurfPoints","turfPoints","turf","smallestSurroundingRectangleByarea","convexHull","allHullCoords","centroid","coordAll","Number","MAX_SAFE_INTEGER","envelope","CheckSegmentsIntersect","Startpoint","Line","CrossX","CrossY","constants","maxXLine","maxYLine","maxXNewLine","maxYNewLine","minXLine","minYLine","minXNewLine","minYNewLine","CheckIfLineInPoly","AllLines","AllPoints","intersectionsCounter","CheckIfPointInPolygon","BasePoints","point2","counter","xinters","LineLength","LinePoints","crossingPoint","getCrossPointBetweenTwoLines","FirstConstants","SecondConstants","plumbPoint","filterStraightLines","PolygonStraightEquations","filteredLines","plumbConstants","crossPoint","NaN","GetLongestStraightLine","maxLength","straightLines","getAllStraightEquations","filteredStraightEquations","n","RectangleSplitter","FinalMinimumWaste","TempMinimumWidth","FinalCounterArray","GrassWidth","SecondWidth","CounterArray","minimizedArray","twos","threes","fours","MinimizeStrips","RectangleMeasures","upDownMeasure","leftRightMeasure","insertPointAtIndex","copyPoints","checkBetterWasteDirection","horizontalArray","verticalArray","SumHorizontal","SumVertical","calcPolygonArea","vertices","total","l","algorithmForOneShape","calcType","RectengularArray","ShapesArray","SplitedArray","LongestPath","Shape","Shapes","MinimumWasteArray","FinalShape","Measures","MinimumWasteWidth","MinimumWasteHeight","newMeasures","roundUp","numOfStripsWidth","numOfStripsHeight","initialPolygonArea","RectangleArea","striperemain","minimumMeasure","roundUpNumber","reOrder","orderedRectangle","vertex","algorithm","ResultArray","MinimumWasteResultArray","MinimumAttachmentsResultArray","MinimumWasteUpDown","MinimumWasteRightLeft","numOfStripesHorizontal","numOfStripesVertical","checkBetterAttachmentsDirection","roundingUp","RoundedPointsArray","roundingUpX","roundingUpY","TransformintoProportion","TranformedPointsArray","TransformedPoint","FindRectPoints","ProportionController","RectangleHandler","stageHeight","OrderedRects","RectPoints","PolygonHandler","OrderedPolygons","polygonPoints","CircleHandler","OrderedCircles","Circle","CircleRectPoints","ChagneResultArray","newResult","openCalc","setopenCalc","ExpansionPanel","ExpansionPanelSummary","expandIcon","Fab","algorithmResult","orderedRects","orderedPolygons","orderedCircles","alert","backgroundColor","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","initial_state","konvaReducer","action","newPoints","newState","CopystateStack","lastState","rootReducer","combineReducers","store","createStore","rootreducer","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.cee573cc.chunk.js","sourcesContent":["import React from 'react';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Tabs from '@material-ui/core/Tabs';\r\nimport Tab from '@material-ui/core/Tab';\r\nimport Table from '@material-ui/core/Table';\r\nimport TableBody from '@material-ui/core/TableBody';\r\nimport TableCell from '@material-ui/core/TableCell';\r\nimport TableContainer from '@material-ui/core/TableContainer';\r\nimport TableHead from '@material-ui/core/TableHead';\r\nimport TableRow from '@material-ui/core/TableRow';\r\n\r\nconst RollsTable = (props) => {\r\n    return(\r\n        <TableContainer component = {Paper}>\r\n            <Table>\r\n                <TableHead>\r\n                    <TableRow>\r\n                        <TableCell align = 'right'> : 2 </TableCell>\r\n                        <TableCell align = 'right'> : 3 </TableCell>\r\n                        <TableCell align = 'right'> : 4 </TableCell>\r\n                        <TableCell align = 'right'>\" </TableCell>\r\n                        <TableCell align = 'right'>\" </TableCell>\r\n                    </TableRow>\r\n                </TableHead>\r\n                <TableBody>\r\n                    <TableRow>\r\n                        <TableCell align = 'right'>{props.row ? props.row.TwoMeter : '0'}</TableCell>\r\n                        <TableCell align = 'right'>{props.row ? props.row.ThreeMeter : '0'}</TableCell>\r\n                        <TableCell align = 'right'>{props.row ? props.row.FourMeter : '0'}</TableCell>\r\n                        <TableCell align = 'right'>{props.row ? Math.floor(props.row.TotalArea) + ' \"' : '0 '}</TableCell>\r\n                        <TableCell align = 'right'>{props.row ? props.row.LeftOvers + ' \"' : '0'}</TableCell>\r\n                    </TableRow>\r\n                </TableBody>\r\n            </Table>\r\n        </TableContainer>\r\n    )\r\n}\r\n\r\nexport default RollsTable","export default __webpack_public_path__ + \"static/media/explain.8f7dba14.PNG\";","import React from 'react'\r\nimport {useEffect, useRef} from 'react'\r\nimport {Rect, Transformer , Text } from 'react-konva';\r\n\r\n\r\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onChange }) => {\r\n    const shapeRef = useRef();\r\n    const trRef = useRef();\r\n  \r\n    useEffect(() => {\r\n      if (isSelected) {\r\n        // we need to attach transformer manually\r\n        trRef.current.nodes([shapeRef.current]);\r\n        trRef.current.getLayer().batchDraw();\r\n      }\r\n    }, [isSelected]);\r\n  \r\n    return (\r\n      <React.Fragment>\r\n        <Rect\r\n          onClick={onSelect}\r\n          onTap={onSelect}\r\n          ref={shapeRef}\r\n          {...shapeProps}\r\n          draggable\r\n          onDragEnd={(e) => {\r\n            onChange({\r\n              ...shapeProps,\r\n              x: e.target.x(),\r\n              y: e.target.y(),\r\n            });\r\n          }}\r\n\r\n          onTransform = {(e) => {\r\n            // transformer is changing scale of the node\r\n            // and NOT its width or height\r\n            // but in the store we have only width and height\r\n            // to match the data better we will reset scale on transform end\r\n            const node = shapeRef.current;\r\n            const scaleX = node.scaleX();\r\n            const scaleY = node.scaleY();\r\n  \r\n            // we will reset it back\r\n            node.scaleX(1);\r\n            node.scaleY(1);\r\n            onChange({\r\n              ...shapeProps,\r\n              x: node.x(),\r\n              y: node.y(),\r\n              // set minimal value\r\n              width: Math.max(5, node.width() * scaleX),\r\n              height: Math.max(node.height() * scaleY),\r\n            });\r\n          }}\r\n\r\n          onTransformEnd={(e) => {\r\n            // transformer is changing scale of the node\r\n            // and NOT its width or height\r\n            // but in the store we have only width and height\r\n            // to match the data better we will reset scale on transform end\r\n            const node = shapeRef.current;\r\n            const scaleX = node.scaleX();\r\n            const scaleY = node.scaleY();\r\n  \r\n            // we will reset it back\r\n            node.scaleX(1);\r\n            node.scaleY(1);\r\n            onChange({\r\n              ...shapeProps,\r\n              x: node.x(),\r\n              y: node.y(),\r\n              // set minimal value\r\n              width: Math.max(5, node.width() * scaleX),\r\n              height: Math.max(node.height() * scaleY),\r\n            });\r\n          }}\r\n        />\r\n       \r\n        {isSelected && (\r\n          <Transformer\r\n            ref={trRef}\r\n            boundBoxFunc={(oldBox, newBox) => {\r\n              // limit resize\r\n              if (newBox.width < 5 || newBox.height < 5) {\r\n                return oldBox;\r\n              }\r\n              return newBox;\r\n            }}\r\n          />\r\n        )}\r\n      </React.Fragment>\r\n    );\r\n  };\r\n  \r\n\r\n\r\n  export default Rectangle","import React from 'react'\r\nimport {useEffect, useRef} from 'react'\r\nimport {Circle, Transformer , Text } from 'react-konva';\r\n\r\n\r\nconst Circular = ({ shapeProps, isSelected, onSelect, onChange }) => {\r\n    const shapeRef = useRef();\r\n    const trRef = useRef();\r\n  \r\n    useEffect(() => {\r\n      if (isSelected) {\r\n        // we need to attach transformer manually\r\n        trRef.current.nodes([shapeRef.current]);\r\n        trRef.current.getLayer().batchDraw();\r\n      }\r\n    }, [isSelected]);\r\n  \r\n    return (\r\n      <React.Fragment>\r\n        <Circle\r\n          onClick={onSelect}\r\n          onTap={onSelect}\r\n          ref={shapeRef}\r\n          {...shapeProps}\r\n          draggable\r\n          onTransform = {(e) => {\r\n            const node = shapeRef.current;\r\n            const scaleX = node.scaleX();\r\n            const scaleY = node.scaleY();\r\n  \r\n            // we will reset it back\r\n            node.scaleX(1);\r\n            node.scaleY(1);\r\n            onChange({\r\n              ...shapeProps,\r\n              x: node.x(),\r\n              y: node.y(),\r\n              // set minimal value\r\n              width: Math.max(5, node.width() * scaleX),\r\n              height: Math.max(node.height() * scaleY),\r\n              radius : (Math.max(5, node.width() * scaleX))\r\n            });\r\n          }}\r\n          onDragMove = {(e) => {\r\n            onChange({\r\n              ...shapeProps,\r\n              x: e.target.x(),\r\n              y: e.target.y(),\r\n            });\r\n          }}\r\n          onDragEnd={(e) => {\r\n            onChange({\r\n              ...shapeProps,\r\n              x: e.target.x(),\r\n              y: e.target.y(),\r\n            });\r\n          }}\r\n          onTransformEnd={(e) => {\r\n            // transformer is changing scale of the node\r\n            // and NOT its width or height\r\n            // but in the store we have only width and height\r\n            // to match the data better we will reset scale on transform end\r\n            const node = shapeRef.current;\r\n            const scaleX = node.scaleX();\r\n            const scaleY = node.scaleY();\r\n  \r\n            // we will reset it back\r\n            node.scaleX(1);\r\n            node.scaleY(1);\r\n            onChange({\r\n              ...shapeProps,\r\n              x: node.x(),\r\n              y: node.y(),\r\n              // set minimal value\r\n              width: Math.max(5, node.width() * scaleX),\r\n              height: Math.max(node.height() * scaleY),\r\n              radius : (Math.max(5, node.width() * scaleX))\r\n            });\r\n          }}\r\n        />\r\n       \r\n        {isSelected && (\r\n          <Transformer\r\n            enabledAnchors = {['top-left' , 'top-right' , 'bottom-right' , 'bottom-left']}\r\n            ref={trRef}\r\n            boundBoxFunc={(oldBox, newBox) => {\r\n              // limit resize\r\n              if (newBox.width < 5 || newBox.height < 5) {\r\n                return oldBox;\r\n              }\r\n              return newBox;\r\n            }}\r\n          />\r\n        )}\r\n      </React.Fragment>\r\n    );\r\n  };\r\n  \r\n\r\n\r\n  export default Circular","import React, { useState } from 'react'\r\nimport konva from 'konva'\r\nimport { Stage, Layer, Group, Line, Rect } from \"react-konva\";\r\nimport { connect , dispatch } from \"react-redux\"\r\nconst Polygon = (props) => {\r\n    const [points , setpoints] = useState([])\r\n    const [curMousePos , setcurMousePos] = useState([0,0])\r\n    const [isMouseOverStartPoint ,setisMouseOverStartPoint] = useState(false)\r\n    const [isFinished , setisFinished] = useState(false)\r\n    const getMousePos = () => {     \r\n        if(props.stage)  {\r\n            return [props.stage.getPointerPosition().x, props.stage.getPointerPosition().y];\r\n        }\r\n       return 0\r\n    };\r\n\r\n   \r\n\r\n    const handleClick = event => {\r\n        console.log('handling click')\r\n        const stage = props.stage;\r\n        const mousePos = getMousePos(stage);\r\n    \r\n        if (isFinished) {\r\n          return;\r\n        }\r\n        if (isMouseOverStartPoint && points.length >= 3) {\r\n            setisFinished(true)\r\n        } else {\r\n          setpoints([...points , mousePos])\r\n        }\r\n      };\r\n\r\n\r\n    const handleMouseMove = event => {\r\n        const stage = props.stage;\r\n        let mousePos = getMousePos(stage);\r\n\r\n        setcurMousePos(mousePos)\r\n      };\r\n\r\n    const handleMouseOverStartPoint = event => {\r\n        if (isFinished || points.length < 3) return;\r\n        event.target.scale({ x: 2, y: 2 });\r\n        setisMouseOverStartPoint(true)\r\n    };\r\n\r\n    const handleMouseOutStartPoint = event => {\r\n        event.target.scale({ x: 1, y: 1 });\r\n        setisMouseOverStartPoint(false)\r\n      };\r\n\r\n    const handleDragStartPoint = event => {\r\n        console.log(\"start\", event);\r\n      };\r\n\r\n    const handleDragMovePoint = event => {\r\n        const points = points;\r\n        const index = event.target.index - 1;\r\n        console.log(event.target);\r\n        const pos = [event.target.attrs.x, event.target.attrs.y];\r\n        console.log(\"move\", event);\r\n        console.log(pos , \"pos\");\r\n        setpoints([...points.slice(0 , index), pos , ...points.slice(index+1) ])\r\n      };\r\n\r\n    const handleDragOutPoint = event => {\r\n        console.log(\"end\", event);\r\n      };\r\n\r\n    const handleDragEndPoint = () => {\r\n        console.log('not defined function')\r\n    }\r\n    const flattenedPoints = points\r\n        .concat(isFinished ? [] : curMousePos)\r\n        .reduce((a, b) => a.concat(b), []);\r\n    \r\n    return(\r\n            <Stage  onMouseDown={handleClick}\r\n            onMouseMove={handleMouseMove}>\r\n            <Layer >\r\n              <Line\r\n                points={flattenedPoints}\r\n                stroke=\"black\"\r\n                strokeWidth={5}\r\n                closed={isFinished}\r\n              />\r\n              {points.map((point, index) => {\r\n                const width = 6;\r\n                const x = point[0] - width / 2;\r\n                const y = point[1] - width / 2;\r\n                const startPointAttr =\r\n                  index === 0\r\n                    ? {\r\n                        hitStrokeWidth: 12,\r\n                        onMouseOver: handleMouseOverStartPoint,\r\n                        onMouseOut: handleMouseOutStartPoint\r\n                      }\r\n                    : null;\r\n                return (\r\n                  <Rect\r\n                    key={index}\r\n                    x={x}\r\n                    y={y}\r\n                    width={width}\r\n                    height={width}\r\n                    fill=\"white\"\r\n                    stroke=\"black\"\r\n                    strokeWidth={3}\r\n                    onDragStart={handleDragStartPoint}\r\n                    onDragMove={handleDragMovePoint}\r\n                    onDragEnd={handleDragEndPoint}\r\n                    draggable\r\n                    {...startPointAttr}\r\n                  />\r\n                );\r\n              })}\r\n            </Layer>\r\n            </Stage>\r\n    )\r\n\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n      proportion : state.konva.proportion,\r\n      accuracy : state.konva.accuracy\r\n  }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    \r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Polygon)","import React from 'react';\r\nimport {useState , useEffect} from 'react'\r\nimport Dialog from '@material-ui/core/Dialog'\r\nimport Grid from '@material-ui/core/Grid'\r\nimport Divider from '@material-ui/core/Divider'\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Tabs from '@material-ui/core/Tabs';\r\nimport Tab from '@material-ui/core/Tab';\r\nimport RollsTable from './RollsTable'\r\nimport { makeStyles , withStyles} from '@material-ui/core/styles';\r\nimport explain from './explain.PNG'\r\nimport { connect , dispatch } from \"react-redux\"\r\nimport {Stage , Layer , Line , Rect , Text , Circle, Arrow} from 'react-konva'\r\nimport Rectangle from '../Konva/Rectangle'\r\nimport Polygon from '../Konva/Polygon'\r\nimport Circular from '../Konva/Circle'\r\nimport {Shape} from 'react-konva'\r\nimport { LastPageRounded } from '@material-ui/icons';\r\nimport Button from '@material-ui/core/Button'\r\nimport ArrowBackIosIcon from '@material-ui/icons/ArrowBackIos';\r\nimport CommunicationStayCurrentLandscape from 'material-ui/svg-icons/communication/stay-current-landscape';\r\nconst useStyles = makeStyles((theme) => ({\r\n    root: {\r\n        [theme.breakpoints.down('sm')]: {\r\n          width : '100%',\r\n        },\r\n        [theme.breakpoints.up('sm')]: {\r\n            width : '100%',\r\n          },\r\n        [theme.breakpoints.up('md')]: {\r\n            width : '100%',\r\n        },\r\n        [theme.breakpoints.up('xl')]: {\r\n            width : '80%',\r\n        },\r\n      },\r\n   \r\n}))\r\n\r\nconst CalcWindow = (props) => {\r\n    let Windowstage = null \r\n    const classes = useStyles();\r\n    const [currentTab , setCurrentTab] = useState(0)\r\n    const [Outerdiv , setOuterdiv] = useState(document.getElementById('parentWindow'))\r\n    const [currentShowTab , setcurrentShowTab] = useState(0)\r\n  \r\n    useEffect(() => {\r\n        setOuterdiv(document.getElementById('parentWindow'))\r\n    }) \r\n\r\n\r\n    useEffect(() => {\r\n     \r\n    }, [props.Polygons , props.Rectangles , props.Circles]) \r\n\r\n    const handleTabChange = (event , newValue) => {\r\n        setCurrentTab(newValue);\r\n    }\r\n\r\n    const handleShowTabChange = (event , newValue) => {\r\n        setcurrentShowTab(newValue);\r\n    }\r\n\r\n    const setStageRef = ref => {\r\n        if (ref) {\r\n            Windowstage = ref;\r\n            props.ChangeStageWindow(ref)\r\n        }\r\n    }; \r\n\r\n    const orderPoints = (Points) => {\r\n        // order the polygon points to match\r\n        let orderedpoints = []\r\n        for(let point = 0 ;point < Points.length-2 ; point++){         \r\n                if(point%2 == 0){\r\n                    orderedpoints.push(Points[point])\r\n                }\r\n                else{\r\n                    orderedpoints.push(Points[point])\r\n                }          \r\n        }\r\n        orderedpoints.push(Points[0])\r\n        orderedpoints.push(Points[1])\r\n        return orderedpoints\r\n    }\r\n\r\n    const SumUpOrder = () => {\r\n        let Stripes = [0,0,0]\r\n        let remain = 0\r\n        for(let Arrayshapes = 0 ; Arrayshapes < props.AlgorithmResult[currentTab].length ; Arrayshapes++){\r\n            for(let shape = 0 ;shape < props.AlgorithmResult[currentTab][Arrayshapes].length ; shape++){\r\n                Stripes[0] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][0]\r\n                Stripes[1] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][1]\r\n                Stripes[2] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][2]\r\n                remain += props.AlgorithmResult[currentTab][Arrayshapes][shape][1]\r\n            }\r\n        }\r\n   \r\n        return [Stripes,remain]\r\n    }\r\n\r\n    const PitagorasSentence = (x , y ,x1, y1) => {\r\n        return(Math.sqrt(Math.pow(Math.abs(y1-y) , 2) + Math.pow(Math.abs(x1-x) , 2)))\r\n    }\r\n\r\n    const BuildStripesString = (counterArray) => {\r\n        let Stripes = counterArray\r\n        return \"(\"+ (Stripes[0] > 0 ? \"2X\"+Stripes[0].toString()+\",\" : \"\")+(Stripes[1] > 0 ? \"3X\"+Stripes[1].toString()+\",\" : \"\")+(Stripes[2] > 0 ? \"4X\"+Stripes[2].toString()+\",\" : \"\")+\")\"\r\n    }\r\n\r\n\r\n    const SumArea = () => {\r\n        let totalArea = 0\r\n        let Stripes = [0,0,0]\r\n        for(let Arrayshapes = 0 ; Arrayshapes < props.AlgorithmResult[currentTab].length ; Arrayshapes++){\r\n            for(let shape = 0 ;shape < props.AlgorithmResult[currentTab][Arrayshapes].length ; shape++){\r\n                Stripes[0] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][0]\r\n                Stripes[1] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][1]\r\n                Stripes[2] += props.AlgorithmResult[currentTab][Arrayshapes][shape][0][2]\r\n                totalArea +=  Stripes[0] * 2 * props.AlgorithmResult[currentTab][Arrayshapes][shape][7]\r\n                totalArea +=  Stripes[1] * 3 * props.AlgorithmResult[currentTab][Arrayshapes][shape][7]\r\n                totalArea +=  Stripes[2] * 4 * props.AlgorithmResult[currentTab][Arrayshapes][shape][7]\r\n                Stripes = [0,0,0]\r\n            }\r\n        }\r\n        return totalArea\r\n    }\r\n\r\n    const Squarelines = [0,1,2,3,4,5,6,7,8,9,10]\r\n    let SquareSize = 60\r\n    let numofSquaresWidth = Outerdiv ? Outerdiv.offsetWidth / SquareSize : 0\r\n    let SquarelinesWidth = []\r\n    for(let i = 0; i <numofSquaresWidth ; i++){\r\n        SquarelinesWidth.push(i)\r\n    }\r\n\r\n    const proportion = (30 / props.proportion)* 2\r\n    let finalResults = [[0,0,0] , 0]\r\n    let TotalArea = 0\r\n    if(props.AlgorithmResult[currentTab]){\r\n         finalResults = SumUpOrder()\r\n    }\r\n    if(props.AlgorithmResult[currentTab]){\r\n        TotalArea = SumArea()\r\n   }\r\n    return(\r\n        <Dialog fullScreen maxWidth = 'xl'   onClose = {props.close} open = {props.open}>                \r\n                <Grid container spacing = {0} style = {{direction : 'rtl'}} direction = 'row'>\r\n                   \r\n                        <Grid item xl = {3}  xs = {3}>\r\n                            <p style = {{direction : 'rtl' , fontSize : '24px' , marginRight : '20px'}}> </p>\r\n                            <Divider variant = 'middle' style = {{width : '15%' , position : 'absolute' , right: '0' ,marginTop : '-20px'}}></Divider>\r\n                        </Grid>\r\n                        <Grid item xs ={8}></Grid>\r\n                        <Grid item xs ={1} style = {{marginTop : '20px'}}>\r\n                            <Button style = {{textTransform : 'none' , color : '#AFD5AA'}} onClick = {props.close}>\r\n                                Back To Editing\r\n                                <ArrowBackIosIcon></ArrowBackIosIcon>\r\n                            </Button>\r\n                           \r\n                        </Grid>\r\n                        <Grid item xl = {6} xs = {6} style = {{ marginRight : '20px'}}>\r\n                            <Paper className = {classes.root}>\r\n                                <Tabs value = {currentTab} indicatorColor = 'primary' textColor = 'primary' onChange = {handleTabChange}>\r\n                                    <Tab label=\" \" /> \r\n                                    <Tab label=\" \" />\r\n                                    <Tab label=\"  +   \"/>\r\n                                    <Tab label=\"  +   \" />\r\n                                </Tabs>\r\n                            </Paper>\r\n                        </Grid>\r\n                        <Grid item xl = {3} xs = {3} style = {{marginRight : '20px'}}>\r\n                            <Paper className = {classes.root}>\r\n                                <Tabs value = {currentShowTab} indicatorColor = 'primary' textColor = 'primary' onChange = {handleShowTabChange}>\r\n                                    <Tab label=\"\"/> \r\n                                    <Tab label=\" \" />                                \r\n                                </Tabs>\r\n                            </Paper>\r\n                        </Grid>\r\n                        {/* <Grid item xl = {2}  xs = {2}>\r\n                            <p style = {{direction : 'rtl' , fontSize : '20px' , marginRight : '20px'}}></p>\r\n                            <Divider variant = 'middle' style = {{width : '15%' , right: '0' ,marginTop : '-15px' ,  marginRight : '20px'}}></Divider>\r\n                        </Grid> */}\r\n\r\n                        <Grid item xl = {6}  xs = {6} style = {{marginTop : '0px'}}>\r\n                            <p style = {{direction : 'rtl' , fontSize : '20px' , marginRight : '20px'}}> </p>\r\n                            <Divider variant = 'middle' style = {{width : '6%' , position : 'absolute' , right: '0' ,marginTop : '-15px' ,  marginRight : '20px'}}></Divider>\r\n                        </Grid>\r\n\r\n                        <Grid item xl = {6} xs = {6}  style = {{ marginRight : '20px'}}>\r\n                            <RollsTable row = {{TwoMeter : finalResults[0][0] , ThreeMeter: finalResults[0][1] , FourMeter : finalResults[0][2] ,TotalArea : TotalArea ,LeftOvers : finalResults[1].toFixed(2)}}></RollsTable>\r\n                        </Grid>\r\n                       \r\n                        {/* <Grid item xl = {6} xs = {6} >\r\n                            <img src = {explain}></img>\r\n                        </Grid> */}             \r\n                    <Grid item xl = {12} xs = {12}>\r\n                        <div id = 'parentWindow' style = {{border : '2px grey solid',marginTop : '20px' ,borderRadius : '10px', height: '56vh' , width : '97vw', marginRight : '20px' }}>\r\n                        <Stage ref={setStageRef}\r\n                           width = {Outerdiv ? Outerdiv.offsetWidth : 0}\r\n                           height = {Outerdiv ? Outerdiv.offsetHeight : 0}\r\n                        > \r\n                        \r\n                            <Layer>\r\n                                {Outerdiv ?\r\n                                Squarelines.map(number => {\r\n                                    return(\r\n                                        <React.Fragment>\r\n                                            <Line points = {[0,(SquareSize)*number,Outerdiv.offsetWidth ,(SquareSize)*number]}  strokeWidth={2}  stroke= 'lightgrey'/>                                                                          \r\n                                        </React.Fragment>                              \r\n                                    )\r\n                                }) : <></>}\r\n                                {Outerdiv ?\r\n                                    SquarelinesWidth.map(number => {\r\n                                        return(\r\n                                            <React.Fragment>\r\n                                                <Line points = {[(Outerdiv.offsetWidth/numofSquaresWidth)*number,0,(Outerdiv.offsetWidth/numofSquaresWidth)*number ,Outerdiv.offsetHeight]}  strokeWidth={2}  stroke= 'lightgrey'/>                                          \r\n                                            </React.Fragment>                              \r\n                                        )\r\n                                }) : <></>}\r\n                            </Layer>\r\n\r\n                            <Layer> \r\n                          \r\n                                {props.Rectangles.map((rect, index) => {  \r\n                                   \r\n                                    return(\r\n                                        <>\r\n                                        <Rectangle\r\n                                        shapeProps = {{...rect , x : rect.x , width : rect.width , height : rect.height ,stroke : currentShowTab === 0 ? '' : 'black', fill : currentShowTab === 0 ? \"#AFD5AA\" : ''}}   \r\n\r\n                                        key = {index}                                                \r\n                                        />\r\n                                        {currentShowTab === 1 ? \r\n                                            <>\r\n                                            {props.Rectangles.map((rect, index) => (                                          \r\n                                                <Text text = {Math.floor(Math.abs(rect.width))/proportion} x = {rect.xDirection = 'right' ? rect.x + (rect.width / 2) : (rect.x - (rect.width / 2))} y={rect.y} fontSize = {20} />\r\n                                                \r\n                                                ))}\r\n                                            {props.Rectangles.map((rect, index) => (                                                              \r\n                                                    <Text text = {Math.floor(Math.abs(rect.height))/proportion} x = {rect.x} y={rect.xDirection = 'up' ? rect.y + (rect.height / 2) : (rect.y - (rect.height / 2))} fontSize = {20} />                     \r\n                                                ))}  \r\n                                                </>\r\n                                                : <></>   \r\n                                        }\r\n                                        </>\r\n                                    )                                                \r\n                                    })}\r\n\r\n                               \r\n                                {props.Circles.map((circle , index) => {\r\n                                    \r\n                                    return(\r\n                                        <>\r\n                                       <Circular \r\n                                       shapeProps = {{...circle , x: circle.x, radius : circle.radius , width : circle.width , height : circle.height , fill : currentShowTab === 0 ? \"#AFD5AA\" : '' , stroke : currentShowTab === 0 ? '' : 'black'}}\r\n                                       key = {index}                                    \r\n                                       />                                                               \r\n                                        {currentShowTab === 1 ? \r\n                                            <Text text= {Math.floor(circle.radius)/proportion/2} x = {circle.x} y = {circle.y} fontSize = {circle.radius < 20 ? 15 : 20}/>\r\n                                            :\r\n                                        <></>} \r\n                                        </> \r\n                                    )               \r\n                                })}\r\n                                {props.Polygons.map((poly , index) =>{       \r\n                                return(     \r\n                                    <>                \r\n                                    {poly.anchorPoints.map((point, index) => {  \r\n                                        return(\r\n                                        <>\r\n                                        <Shape\r\n                                        sceneFunc={(context, shape) => {\r\n                                            context.beginPath();\r\n                                            if(poly.points[index] && poly.points[index+1]){\r\n                                            context.moveTo(poly.points[index][0] , poly.points[index][1]);\r\n                                            context.quadraticCurveTo(point[0] , point[1],poly.points[index+1][0] ,poly.points[index+1][1]);\r\n                                            }\r\n                                            else{\r\n                                                if(index === poly.points.length-1){\r\n                                                    context.moveTo(poly.points[index][0] , poly.points[index][1]);\r\n                                                    context.quadraticCurveTo(point[0] , point[1],poly.points[0][0] ,poly.points[0][1]);\r\n                                                }\r\n                                            }\r\n                                            // (!) Konva specific method, it is very important\r\n                                            context.fillStrokeShape(shape);                                          \r\n                                            }}                      \r\n                                            stroke = {currentShowTab === 0 ? '' : 'black'}                                              \r\n                                            strokeWidth={4}/>                                                                                   \r\n                                        </>                                  \r\n                                        )    \r\n                                    })}                                                                    \r\n                                    \r\n                                     {poly.flattenedPoints.map((point, index) => {    \r\n                                        let x = -500\r\n                                        let y = -500\r\n                                        let x1 = poly.flattenedPoints[index+2]\r\n                                        let y1 = poly.flattenedPoints[index+3]\r\n                                        if(index % 2 === 0 && index +3 < poly.flattenedPoints.length){                                  \r\n                                            x = (point + poly.flattenedPoints[index+2]) / 2;\r\n                                            y = (poly.flattenedPoints[index+1] + poly.flattenedPoints[index+3]) / 2;  \r\n                                        }                                 \r\n                                        return (\r\n                                            currentShowTab === 1 ?\r\n                                            index % 2 === 0?\r\n                                            <Text text={(parseFloat((PitagorasSentence(x,y,x1,y1))) / proportion*2).toFixed(2)} x={x} y={y} fontSize={20} /> : \r\n                                            <></> : <></>\r\n                                        );\r\n                                        })}</>)\r\n                            })}                                  \r\n                            {props.Polygons.map((poly , index) =>{  \r\n                                                        \r\n                                return(                                         \r\n                                         <Line closed = {true} points = {orderPoints(poly.flattenedPoints)} strokeWidth={4}  fill = {currentShowTab === 0 ? \"#AFD5AA\" : ''}>\r\n                                        </Line>                                                                      \r\n                                   )                                                            \r\n                            })}          \r\n                           \r\n                                \r\n                       \r\n                            </Layer>   \r\n                        {currentShowTab === 0 ? \r\n                            <Layer>                          \r\n                                    {props.AlgorithmResult[currentTab] ? props.AlgorithmResult[currentTab].map((allRects, index) => {   \r\n                                        return(\r\n                                        allRects.map((rect , index)=> {   \r\n                                            console.log(rect , 'rect in result')                    \r\n                                            let coreWidth = Math.abs(rect[3][0][0] -  rect[3][1][0])\r\n                                            let remainArea = rect[5]\r\n                                            let length = rect[2]\r\n                                            let coreHeight =Math.abs(rect[3][0][1] -  rect[3][2][1])    \r\n                                            let Width = (coreWidth + (length !== coreWidth?  remainArea: 0))*proportion       \r\n                                            let Height = (coreHeight + (length !== coreHeight?  remainArea: 0))*proportion               \r\n                                            let X = rect[3][0][0]*proportion\r\n                                            let Y =  props.height-(rect[3][0][1]*proportion)                                       \r\n                                        return(\r\n                                            <>\r\n                                            <Rectangle\r\n                                            shapeProps ={{x : rect[3][0][0]*proportion , \r\n                                                        y : props.height-(rect[3][0][1]*proportion) , \r\n                                                        width : (coreWidth + (length !== coreWidth?  remainArea: 0))*proportion\r\n                                                 , height: (coreHeight + (length !== coreHeight?  remainArea: 0))*proportion , stroke : 'grey',dash: [10, 10], strokeWidth : 3}}\r\n                                            \r\n                                            key = {index}                                                \r\n                                            />\r\n                                            <Text text = {parseFloat((coreWidth + (length !== coreWidth?  remainArea : 0))).toFixed(2)} x = {rect[3][0][0]*proportion + (coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2} y= {props.height - (rect[3][0][1]*proportion) - 30 + ((coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2)}  fontSize = {20} />\r\n                                            <Text text = {parseFloat((coreHeight + (length !== coreHeight?  remainArea : 0))).toFixed(2)} x = {rect[3][0][0]*proportion - 30 + ((coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2-30)} y= {props.height - (rect[3][0][1]*proportion) + (coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2}  fontSize = {20} />\r\n                                            {length === coreWidth? \r\n                                            <>\r\n                                                <Text text = {'(' + rect[7].toString() + ')'} x = {rect[3][0][0]*proportion + (coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2 + 40} y= {props.height - (rect[3][0][1]*proportion) - 25 + ((coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2)}  fontSize = {12} />\r\n                                                <Text text = {BuildStripesString(rect[0])} x = {rect[3][0][0]*proportion - 10 + ((coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2-70)} y= {props.height - (rect[3][0][1]*proportion) + (coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2 + 20}  fontSize = {12} />\r\n                                  \r\n                                             </>\r\n                                            :\r\n                                            <>\r\n                                                <Text text = {'(' + rect[7].toString() + ')'} x = {rect[3][0][0]*proportion - 10 + ((coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2-30)} y= {props.height - (rect[3][0][1]*proportion) + (coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2 + 20}  fontSize = {12} />\r\n                                                <Text text = {BuildStripesString(rect[0])} x = {rect[3][0][0]*proportion + (coreWidth + (length !== coreWidth?  remainArea: 0))*proportion/2 + 40} y= {props.height - (rect[3][0][1]*proportion) - 12 + ((coreHeight + (length !== coreHeight?  remainArea: 0))*proportion/2)}  fontSize = {12} />\r\n                                            </>\r\n                                            }\r\n                                           <Arrow  points = {rect[6] === 'right' ? [X + Width/2,Y + Height/2,X+Width/2+30 , Y + Height/2]  : [X + Width/2,Y + Height/2,X+Width/2 , Y + Height/2+30]} stroke = \"black\" strokeWidth = \"black\" fill = \"black\"/>\r\n                                            </>\r\n                                        )}))                                             \r\n                                    }) : <></>}\r\n                            </Layer> : <></>}\r\n\r\n                        </Stage>\r\n                        </div>\r\n                    </Grid>\r\n                </Grid>      \r\n        </Dialog>\r\n    )\r\n} \r\n\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        Polygons : state.konva.Polygons,\r\n        height : state.konva.height,\r\n        Rectangles : state.konva.Rectangles,\r\n        Circles : state.konva.Circles,\r\n        mode : state.konva.mode,\r\n        Windowstage : state.konva.Windowstage,\r\n        AlgorithmResult : state.konva.AlgorithmResult,\r\n        proportion : state.konva.proportion\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        ChangeMode: (newMode) => dispatch({type : 'ChangeMode' , newMode : newMode}),\r\n        ChangeStageWindow: (newWindowstage) => dispatch({type : 'ChangeStageWindow' , newWindowstage : newWindowstage}),\r\n        UpdateCircles : (newCircles) => dispatch({type : 'UpdateCircles' , newCircles : newCircles}),\r\n        UpdatePolygons : (newPolygons) => dispatch({type : 'UpdatePolygons' , newPolygons : newPolygons}),\r\n        UpdateRectangles : (newRectangles) => dispatch({type : 'UpdateRectangles' , newCircles : newRectangles})\r\n    }\r\n}\r\n\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(CalcWindow)","import React from 'react'\r\nimport Grid from '@material-ui/core/Grid';\r\nimport ToggleButton from '@material-ui/lab/ToggleButton';\r\nimport ToggleButtonGroup from '@material-ui/lab/ToggleButtonGroup';\r\nimport {useState , useEffect} from 'react'\r\nimport FiberManualRecord from '@material-ui/icons/FiberManualRecord'\r\nimport ShowChart from '@material-ui/icons/ShowChart'\r\nimport Stop from '@material-ui/icons/Stop'\r\nimport {connect,dispatch} from 'react-redux'\r\nimport Button from '@material-ui/core/Button'\r\nimport UndoIcon from '@material-ui/icons/Undo';\r\nimport LayersClearIcon from '@material-ui/icons/LayersClear';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport Slider from '@material-ui/core/Slider'\r\nimport Typography from '@material-ui/core/Typography'\r\n\r\nconst DrawToolBar = (props) => {\r\n\r\n\r\n    const handleChange = (event ,newMode) => {\r\n        props.ChangeMode(newMode)\r\n    }\r\n\r\n    const inputProps = {\r\n        step : 10,\r\n        min : 10,\r\n        max : 100\r\n    }\r\n\r\n    const valuetext = (value) => {\r\n     \r\n        return `${value}CM`;\r\n      }\r\n\r\n    return (\r\n        <Grid container direction = 'row' style = {{height : '100%' , width : '100%'}}>\r\n           <Grid item xl = {1} md = {0} style = {{marginRight : '1vw'}}></Grid>\r\n            <Grid item xs = {1} style = {{alignItems : 'center' , marginTop : '1vh'}}>\r\n                <Button onClick = {props.Reset} style = {{ boxShadow : '2px 2px 2px 2px grey' , border : '2px solid grey'}}>\r\n                    <LayersClearIcon></LayersClearIcon>\r\n                </Button>\r\n            </Grid>\r\n            <Grid item xs = {1} style = {{alignItems : 'right',marginTop : '1vh'}}>                                        \r\n                  <p style = {{marginRight:'-2vw'}}>Reset</p>                    \r\n            </Grid>\r\n            <Grid item xs = {1} style = {{alignItems : 'center' , marginTop : '1vh'}}>                                        \r\n                    <Button onClick = {props.Undo} style = {{margin : '0px',boxShadow : '2px 2px 2px 2px grey' , border : '2px solid grey'}}>\r\n                        <UndoIcon></UndoIcon>             \r\n                    </Button>                                      \r\n            </Grid>\r\n            <Grid item xs = {1} style = {{alignItems : 'right',marginTop : '1vh'}}>                                        \r\n                  <p style = {{marginRight:'-2vw'}}>Undo</p>                    \r\n            </Grid>\r\n            <Grid item xl = {2} xs = {3} style = {{alignItems : 'center' , width : '50%'}}>\r\n                <ToggleButtonGroup size = \"large\" value = {props.mode} exclusive onChange = {handleChange} style = {{marginTop : '1vh' , boxShadow : '2px 2px 2px 2px grey'}}>\r\n                    <ToggleButton value = \"Rect\">\r\n                        <Stop/>\r\n                    </ToggleButton>\r\n                    <ToggleButton value = \"Polygon\">\r\n                        <ShowChart/>\r\n                    </ToggleButton>\r\n                    <ToggleButton value = \"Circle\">\r\n                        <FiberManualRecord/>\r\n                    </ToggleButton>\r\n                    <ToggleButton value = \"Ellipse\">\r\n                        <FiberManualRecord/>\r\n                    </ToggleButton>\r\n\r\n                </ToggleButtonGroup>\r\n            </Grid>\r\n            <Grid item xs = {2}>\r\n                <TextField style = {{marginTop : '1vh',width :'12vw' , direction : 'rtl'}}\r\n                    id=\"standard-number\"\r\n                    label=\"proportion (meter per square)\"\r\n                    type=\"number\"\r\n                    defaultValue = {1}\r\n                    value = {props.proportion}\r\n                    onChange = {(event) => {props.ChangeProportion(event.target.value)}}\r\n                    InputLabelProps={{\r\n                        shrink: true,\r\n                    }}\r\n                    variant=\"outlined\"\r\n                />\r\n            </Grid>\r\n            \r\n            <Grid item xs = {2}>\r\n                <Typography style= {{marginTop:'1vh' , marginBottom : '-10px'}} id=\"discrete-slider\" gutterBottom>\r\n                      (   )\r\n                </Typography>\r\n                <Slider\r\n                    defaultValue={10}\r\n                    getAriaValueText={(value) => {valuetext(value)}}    \r\n                    onChange = {(event , value) => {props.ChangeAccuracy(value)}}\r\n                    aria-labelledby=\"discrete-slider\"\r\n                    valueLabelDisplay=\"auto\"      \r\n                    step={10}\r\n                    marks\r\n                    min={10}\r\n                    max={100}\r\n                    \r\n                />              \r\n            </Grid>\r\n        </Grid>\r\n    )\r\n\r\n}\r\n\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        mode : state.konva.mode,\r\n        proportion : state.konva.proportion,\r\n        accuracy : state.konva.accuracy\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        ChangeMode: (newMode) => dispatch({type : 'ChangeMode' , newMode : newMode}),\r\n        Undo : () => dispatch({type: 'Undo'}),\r\n        Reset : () => dispatch({type: 'Reset'}),\r\n        ChangeProportion : (newProportion) => dispatch({type : 'ChangeProportion' , newProportion : newProportion }),\r\n        ChangeAccuracy : (newAccuracy) => dispatch({type : 'ChangeAccuracy' , newAccuracy : newAccuracy })\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(DrawToolBar)","import React , {useEffect, useState} from 'react'\r\nimport {Stage , Layer , Line , Rect , Text , Circle} from 'react-konva'\r\nimport DrawToolBar from './DrawToolBar'\r\nimport Grid from '@material-ui/core/Grid'\r\nimport { connect , dispatch } from \"react-redux\"\r\nimport Rectangle from './Rectangle'\r\nimport TransLine from './copiedPolygon'\r\nimport Polygon from './Polygon'\r\nimport { ContactlessOutlined, ContactSupport } from '@material-ui/icons'\r\nimport Circular from './Circle'\r\nimport {Shape} from 'react-konva'\r\nimport Decimal from 'decimal.js'\r\n\r\nconst KonvaContainer = (props) => {\r\n    let stage = null \r\n    const [Outerdiv , setOuterdiv] = useState(document.getElementById('parent'))\r\n    const [currentLine, setCurrentLine] = useState(null);\r\n    const [currentRect , setCurrentRect] = useState(null)\r\n    const [color, setColor] = useState(\"black\");\r\n    const [lines, setLines] = useState([]);\r\n    const [selectedId, selectShape] = useState(null);\r\n    const [points , setpoints] = useState([])\r\n    const [anchorPoints , setAnchorPoints] = useState([])\r\n    const [curMousePos , setcurMousePos] = useState([0,0])\r\n    const [isMouseOverStartPoint ,setisMouseOverStartPoint] = useState(false)\r\n    const [isFinished , setisFinished] = useState(false)\r\n  \r\n    const [DraggedPolygon,setDraggedPolygon] = useState(0)\r\n    const [DraggedPoint,setDraggedPoint] = useState(null)\r\n    const [currentCircle , setCurrentCircle]= useState(null)\r\n  \r\n    const [selectedcircleId , setSelectedcircleId] = useState(null)\r\n    const [startPoint , setStartPoint] = useState([30,60])\r\n    const [endPoint , setEndPoint] = useState([60,120])\r\n    const [curvePoint , setCurvePoint] = useState([45,90])\r\n    const [anchor, setAnchor] = useState([{x : startPoint[0] , y : startPoint[1] , radius : 5 , id  : 1 , stroke : 'black' , fill : 'grey'},{x : curvePoint[0] , y : curvePoint[1] , radius : 5 , id:3, stroke : 'black' , fill : 'grey'},{x : endPoint[0] , y : endPoint[1] , radius : 5 , id : 2, stroke : 'black' , fill : 'grey'}])\r\n    const [DraggedAnchor ,setDraggedAnchor] = useState(0)\r\n    const proportionConst = 30\r\n    const proportion = proportionConst / (props.proportion)\r\n    \r\n    useEffect(() => {\r\n        setOuterdiv(document.getElementById('parent'))\r\n        props.ChangeHeight(document.getElementById('parent').offsetHeight)\r\n    }, [])  \r\n\r\n    const checkDeselect = (e) => {\r\n        // deselect when clicked on empty area\r\n        const clickedOnEmpty = e.target === e.target.getStage();\r\n        if (clickedOnEmpty) {\r\n          selectShape(null);\r\n          setSelectedcircleId(null);\r\n        }\r\n    };\r\n    \r\n    const getMousePos = () => {     \r\n        if(props.stage)  {\r\n            return [props.stage.getPointerPosition().x, props.stage.getPointerPosition().y];\r\n        }\r\n       return 0\r\n    }\r\n\r\n\r\n\r\n    const FindPoint = (source, length,  slope , EquatePoint) =>      \r\n    {\r\n\r\n      // m is the slope of line, and the\r\n      // required Point lies distance l\r\n      // away from the source Point\r\n      let a = []\r\n      let b = []\r\n\r\n      // Slope is 0\r\n      if (slope == 0)\r\n      {\r\n      a[0] = source[0] + length;\r\n      a[1] = source[1];\r\n\r\n      b[0] = source[0] - length;\r\n      b[1] = source[1];\r\n      }\r\n\r\n      // If slope is infinte\r\n      else if (slope === Infinity || slope === -Infinity)\r\n      {\r\n      a[0] = source[0];\r\n      a[1] = source[1] + length;\r\n\r\n      b[0] = source[0];\r\n      b[1] = source[1] - length;\r\n      }\r\n      else\r\n      {\r\n      let dx = (length / Math.sqrt( 1 + (slope * slope)));      \r\n      let dy = slope * dx;\r\n      a[0] = source[0] + dx;\r\n      a[1] = source[1] + dy;\r\n      b[0] = source[0] - dx;\r\n      b[1] = source[1] - dy;\r\n      }\r\n\r\n      if(Math.abs(a[0] - EquatePoint[0]) < Math.abs(b[0] - EquatePoint[0])){\r\n       \r\n        return a\r\n      }\r\n      else{\r\n       \r\n        return b\r\n      }\r\n\r\n    }\r\n\r\n  const calculateSlope = (x,y,x1,y1) =>{\r\n    return (y-y1)/(x-x1)\r\n  }\r\n\r\n    const checkIfTouchPoly = (point) => {\r\n        for(let i = 0 ; i< props.Polygons.length ; i++){          \r\n            for(let j = 0 ; j < props.Polygons[i]['flattenedPoints'].length-1 ; j+=2){\r\n                if(-10 <= point[0] - props.Polygons[i]['flattenedPoints'][j] &&point[0] - props.Polygons[i]['flattenedPoints'][j] <= 10&&-10 <= point[1] - props.Polygons[i]['flattenedPoints'][j+1]&&point[1] - props.Polygons[i]['flattenedPoints'][j+1] <= 10){\r\n                    return true\r\n                }\r\n                if(point[0] === props.Polygons[i]['flattenedPoints'][props.Polygons[i]['flattenedPoints'].length-1][0] && point[1] === props.Polygons[i]['flattenedPoints'][props.Polygons[i]['flattenedPoints'].length-1][1])\r\n                {\r\n                    return true\r\n                }\r\n            }\r\n            for(let j = 0 ; j < props.Polygons[i]['anchorPoints'].length ; j+=1){\r\n                if(-10 <= point[0] - props.Polygons[i]['anchorPoints'][j][0] &&point[0] - props.Polygons[i]['anchorPoints'][j][0] <= 10&&-10 <= point[1] - props.Polygons[i]['anchorPoints'][j][1]&&point[1] - props.Polygons[i]['anchorPoints'][j][1] <= 10){\r\n                    return true\r\n                }\r\n                if(point[0] === props.Polygons[i]['anchorPoints'][props.Polygons[i]['anchorPoints'].length-1][0] && point[1] === props.Polygons[i]['anchorPoints'][props.Polygons[i]['anchorPoints'].length-1][1])\r\n                {\r\n                    return true\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false\r\n    }\r\n\r\n    const onMouseDown = (e) => {\r\n        checkDeselect(e)\r\n        const {x, y} = stage.getPointerPosition();\r\n        if(props.mode === 'Line'){\r\n            setCurrentLine({ x0: x , y0:y , color});\r\n        }\r\n        if(props.mode === 'Polygon'){\r\n            const stage = props.stage;\r\n            let mousePos = getMousePos(stage);\r\n            if(checkIfTouchPoly(mousePos)){\r\n            \r\n            }\r\n            else\r\n            {\r\n                if (isFinished) {\r\n                return;\r\n                }\r\n                if (isMouseOverStartPoint && props.points.length >= 3) {\r\n                    setisFinished(true)\r\n                    let anchorpoints = []\r\n                    flattenedPoints.map((point,index) => {\r\n                        if(index % 2 === 0 && index < flattenedPoints.length - 3){\r\n                            anchorpoints = [...anchorpoints , [((flattenedPoints[index] + flattenedPoints[index+2])/2) ,((flattenedPoints[index + 1] + flattenedPoints[index+3])/2) , false]]\r\n                        }\r\n                    })                                   \r\n                    props.UpdatePolygons([...props.Polygons , {flattenedPoints : [...flattenedPoints] , points : [...props.points],anchorPoints : [...anchorpoints] ,closed : true }])                  \r\n                    props.emptyPoints()\r\n                    setcurMousePos([0,0])\r\n                    setisFinished(false)\r\n                    setisMouseOverStartPoint(false)\r\n                    props.actionTrigger()\r\n                } else {     \r\n                    let x = mousePos[0]\r\n                    let y = mousePos[1]\r\n                   \r\n                    if(props.points.length > 0){\r\n                      let x0 = props.points[props.points.length-1][0]\r\n                      let y0 = props.points[props.points.length-1][1]\r\n                      //current length in pixels\r\n                      let pixelLength = Math.sqrt(Math.pow(x-x0 ,2) + Math.pow(y-y0,2))\r\n                      // transform to cm size\r\n                      let CmLength = pixelLength/(60/props.proportion)*100\r\n                      // calculate how many cm's need to be added \r\n                      let CmRemain = props.accuracy - CmLength%props.accuracy\r\n                      let PixelRemain = (CmRemain/100) * (60/props.proportion)\r\n                      let slope = calculateSlope(x,y,x0,y0)\r\n                      mousePos =  FindPoint([x0,y0] ,pixelLength+PixelRemain,slope ,[x,y])\r\n                    }\r\n                              \r\n                    props.AddPoint(mousePos)\r\n                    props.actionTrigger()\r\n                   \r\n                }\r\n        }\r\n        }\r\n        if(props.mode === 'Rect'){\r\n            setCurrentRect({x : x , y : y})\r\n        }\r\n        if(props.mode === 'Circle'){\r\n            setCurrentCircle({x : x , y : y})\r\n        }   \r\n    }\r\n\r\n    const onMouseMove = () => {\r\n       \r\n        let {x, y} = stage.getPointerPosition();\r\n        const mousePos = getMousePos();\r\n        setcurMousePos(mousePos)\r\n \r\n        \r\n        if(props.mode === 'Line')\r\n        {\r\n            if (currentLine) {\r\n            switch (props.mode) {\r\n                case \"Line\":\r\n                const x0 = currentLine.x0;\r\n                const y0 = currentLine.y0;\r\n                setCurrentLine({\r\n                    ...currentLine,\r\n                    x0 : x0,\r\n                    y0 : y0, \r\n                    x : x,\r\n                    y : y\r\n                });\r\n                break;\r\n                default:\r\n            }\r\n            }\r\n        }\r\n        if(props.mode === 'Rect'){\r\n            if(currentRect) {\r\n                console.log(proportionConst)\r\n                const x0 = currentRect.x\r\n                const y0 = currentRect.y\r\n                let diffrenceX =  Math.abs(x-x0)\r\n                let diffrenceY =  Math.abs(y-y0)\r\n                if(x>x0){               \r\n                    //amount of cm need to add\r\n                    let cmAddX = props.accuracy - (diffrenceX/(proportionConst*2/props.proportion) * 100 )% props.accuracy\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddX = cmAddX*(proportionConst*2/(props.proportion))/100\r\n                    x += pixelAddX\r\n                }\r\n                else{\r\n                    let cmAddX = props.accuracy - ((diffrenceX/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddX = (cmAddX * (proportionConst*2 / props.proportion)) / 100\r\n                    x -=  pixelAddX\r\n                }\r\n                if(y>y0){               \r\n                    //amount of cm need to add\r\n                    let cmAddY = props.accuracy - ((diffrenceY/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddY = (cmAddY * (proportionConst*2 / props.proportion)) / 100\r\n                    y +=  pixelAddY\r\n                }\r\n                else{\r\n                     //amount of cm need to add\r\n                     let cmAddY = props.accuracy - ((diffrenceY/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                     // the amount of pixels need to be added\r\n                     let pixelAddY = (cmAddY * (proportionConst*2 / props.proportion)) / 100\r\n                     y -=  pixelAddY\r\n                }\r\n               \r\n                setCurrentRect({\r\n                    ...currentRect ,\r\n                  \r\n                    width : x>x0 ? x - x0 : -(x0-x),\r\n                    height : y>y0 ? y - y0 : -(y0-y)\r\n                })\r\n            }\r\n        }\r\n\r\n        if(props.mode === 'Circle') {\r\n            if(currentCircle){\r\n                const x0 = currentCircle.x\r\n                const y0 = currentCircle.y\r\n                let radius =  PitagorasSentence(x,y,x0,y0)/(60/props.proportion) * 100 \r\n                radius += (props.accuracy/2) - (radius% (props.accuracy/2))\r\n                radius = radius*(60/props.proportion) / 100\r\n               \r\n                setCurrentCircle({\r\n                    ...currentCircle ,        \r\n                    radius : radius,           \r\n                })\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    const onMouseUp = () => {\r\n        let {x, y} = stage.getPointerPosition();\r\n       \r\n        if(props.mode === 'Line')\r\n        {\r\n           \r\n            setLines([\r\n            ...lines,\r\n            {color : currentLine.color ,points : [currentLine.x0 ,currentLine.y0 ,currentLine.x ,currentLine.y],id : 'Line'+lines.length.toString() ,stroke  : 'black' , strokeWidth : 2}\r\n            ]);\r\n            props.actionTrigger()\r\n            setCurrentLine(null);\r\n        }\r\n        if(props.mode === 'Rect'){\r\n            \r\n            const x0 = currentRect.x\r\n            const y0 = currentRect.y   \r\n            let diffrenceX =  Math.abs(x-x0)\r\n                let diffrenceY =  Math.abs(y-y0)\r\n                if(x>x0){               \r\n                    //amount of cm need to add\r\n                    let cmAddX = props.accuracy - ((diffrenceX/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddX = (cmAddX * (proportionConst*2 / props.proportion)) / 100\r\n                    x +=  pixelAddX\r\n                }\r\n                else{\r\n                    let cmAddX = props.accuracy - ((diffrenceX/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddX = (cmAddX * (proportionConst*2 / props.proportion)) / 100\r\n                    x -=  pixelAddX\r\n                }\r\n                if(y>y0){               \r\n                    //amount of cm need to add\r\n                    let cmAddY = props.accuracy - ((diffrenceY/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                    // the amount of pixels need to be added\r\n                    let pixelAddY = (cmAddY * (proportionConst*2 / props.proportion)) / 100\r\n                    y +=  pixelAddY\r\n                }\r\n                else{\r\n                     //amount of cm need to add\r\n                     let cmAddY = props.accuracy - ((diffrenceY/(proportionConst*2/props.proportion) * 100 )% props.accuracy)\r\n                     // the amount of pixels need to be added\r\n                     let pixelAddY = (cmAddY * (proportionConst*2 / props.proportion)) / 100\r\n                     y -=  pixelAddY\r\n                }\r\n            if(Math.abs(x0-x) < 10 && Math.abs(y0-y) < 10){\r\n\r\n            } \r\n            else{\r\n            props.UpdateRectangles([\r\n                ...props.Rectangles,\r\n                {...currentRect ,x: x>x0 ? x0 : x, y : y>y0 ? y0 : y, width : x>x0 ? x - x0 : x0-x,height : y>y0 ? y - y0 : y0-y , id : 'Rect'+props.Rectangles.length.toString() , stroke  : 'black',xDirection : x>x0 ? 'right' : 'left' ,yDirection : y>y0 ? 'up' : 'down'  , strokeWidth : 2}                    \r\n            ])\r\n            }\r\n            setCurrentRect(null)\r\n            props.actionTrigger()\r\n        }\r\n        if(props.mode === 'Circle'){\r\n            const x0 = currentCircle.x\r\n            const y0 = currentCircle.y   \r\n            // radius in cm\r\n            let radius =  PitagorasSentence(x,y,x0,y0)*2/(60/props.proportion) * 100 \r\n            radius += props.accuracy - (radius% props.accuracy)\r\n            radius = radius*(60/props.proportion) / 100\r\n            if(Math.abs(x0-x) < 10 && Math.abs(y0-y) < 10){\r\n\r\n            } \r\n            else{   \r\n            props.UpdateCircles([\r\n                ...props.Circles,\r\n                {...currentCircle ,radius :radius,width : PitagorasSentence(x,y,x0,y0)*2,height : PitagorasSentence(x,y,x0,y0)*2, id : 'Circle'+props.Circles.length.toString() , stroke  : 'black',strokeWidth : 2}                    \r\n            ])\r\n            props.actionTrigger()\r\n            }\r\n            \r\n            setCurrentCircle(null)\r\n        }\r\n       \r\n      };\r\n\r\n\r\n      \r\n    const setStageRef = ref => {\r\n        if (ref) {\r\n            stage = ref;\r\n            props.ChangeStage(ref)\r\n        }\r\n    }; \r\n\r\n    const handleMouseOverStartPoint = event => {\r\n        if (isFinished || props.points.length < 3) return;\r\n        event.target.scale({ x: 2, y: 2 });\r\n        setisMouseOverStartPoint(true)\r\n    };\r\n\r\n    const handleMouseOutStartPoint = event => {\r\n        event.target.scale({ x: 1, y: 1 });\r\n        setisMouseOverStartPoint(false)\r\n      };\r\n\r\n    const handleDragStartPoint = event => {\r\n\r\n        const pos = [event.target.attrs.x, event.target.attrs.y];\r\n        for(let polygon = 0 ; polygon < props.Polygons.length ; polygon++){\r\n            for(let point = 0 ; point < props.Polygons[polygon]['points'].length ; point++){\r\n                if(-3 <= pos[0] - props.Polygons[polygon]['points'][point][0]  && pos[0] - props.Polygons[polygon]['points'][point][0] <= 3 && -3 <= pos[1] - props.Polygons[polygon]['points'][point][1] &&pos[1] - props.Polygons[polygon]['points'][point][1]  <= 3 ){\r\n                    setDraggedPolygon(polygon)\r\n                    setDraggedPoint(point)\r\n                   \r\n                }\r\n            }\r\n            for(let anchor = 0 ; anchor < props.Polygons[polygon]['anchorPoints'].length ; anchor++){\r\n                if(-3 <= pos[0] - props.Polygons[polygon]['anchorPoints'][anchor][0]  && pos[0] - props.Polygons[polygon]['anchorPoints'][anchor][0] <= 3 && -3 <= pos[1] - props.Polygons[polygon]['anchorPoints'][anchor][1] &&pos[1] - props.Polygons[polygon]['anchorPoints'][anchor][1]  <= 3 ){\r\n                    setDraggedPolygon(polygon)\r\n                    setDraggedAnchor(anchor)\r\n                 \r\n                }\r\n            }\r\n\r\n        }\r\n\r\n      \r\n    };\r\n\r\n    const handleDragMovePoint = event => {\r\n        if(DraggedPoint !== null) {\r\n            const pos = [event.target.attrs.x, event.target.attrs.y];\r\n            let flattenddots = props.Polygons[DraggedPolygon]['flattenedPoints'];\r\n            let dots = props.Polygons[DraggedPolygon]['points']\r\n            const index = event.target.index - 1;\r\n            dots[DraggedPoint] = pos\r\n            flattenddots[DraggedPoint*2] = pos[0]\r\n            flattenddots[(DraggedPoint*2)+1] = pos[1]\r\n            if(DraggedPoint === 0){\r\n                flattenddots[props.Polygons[DraggedPolygon]['flattenedPoints'].length - 2] = pos[0]\r\n                flattenddots[props.Polygons[DraggedPolygon]['flattenedPoints'].length - 1] = pos[1]\r\n            }\r\n            let anchorDots = [];\r\n          \r\n            flattenddots.map((point,index) => {\r\n                if(index % 2 === 0 && index < flattenddots.length - 3 ){\r\n                    \r\n                    if(props.Polygons[DraggedPolygon]['anchorPoints'][index/2][2] ===false){                             \r\n                        anchorDots = [...anchorDots , [(flattenddots[index] + flattenddots[index+2])/2 ,(flattenddots[index + 1] + flattenddots[index+3])/2 , false]]\r\n                    }\r\n                    if( props.Polygons[DraggedPolygon]['anchorPoints'][index/2][2] ===true){\r\n                        anchorDots = [...anchorDots , [...props.Polygons[DraggedPolygon]['anchorPoints'][index/2] , true]]\r\n                }\r\n\r\n                }\r\n            })\r\n            let CopyPolygons = [...props.Polygons]\r\n            CopyPolygons[DraggedPolygon]['flattenedPoints'] = flattenddots\r\n            CopyPolygons[DraggedPolygon]['points'] = dots\r\n            CopyPolygons[DraggedPolygon]['anchorPoints'] = anchorDots\r\n            props.UpdatePolygons(CopyPolygons)\r\n        }\r\n        else{\r\n            const pos = [event.target.attrs.x, event.target.attrs.y , true];\r\n            let anchorDots  = props.Polygons[DraggedPolygon]['anchorPoints'];\r\n            anchorDots[DraggedAnchor] = pos\r\n            let CopyPolygons = [...props.Polygons]\r\n            CopyPolygons[DraggedPolygon]['anchorPoints'] = anchorDots\r\n            props.UpdatePolygons(CopyPolygons)\r\n        }\r\n        \r\n      };\r\n\r\n    const handleDragOutPoint = event => {\r\n\r\n    };\r\n\r\n    const handleDragEndPoint = () => {\r\n       setDraggedPoint(null)\r\n       setDraggedAnchor(null)\r\n    }\r\n\r\n    const flattenedPoints = props.points\r\n        .concat(isFinished ? [] : curMousePos)\r\n        .reduce((a, b) => a.concat(b), []);\r\n \r\n\r\n    const PitagorasSentence = (x , y ,x1, y1) => {\r\n        return(Math.sqrt(Math.pow(Math.abs(y1-y) , 2) + Math.pow(Math.abs(x1-x) , 2)))\r\n    }\r\n\r\n\r\n    window.onkeypress = function(event) {\r\n        if (event.keyCode == 100) {\r\n\r\n          props.Undo()\r\n        }\r\n    }\r\n\r\n\r\n    const Squarelines = [0,1,2,3,4,5,6,7,8,9,10]\r\n    // the size of one background square\r\n    let SquareSize = 60\r\n    let numofSquaresWidth = Outerdiv ? Outerdiv.offsetWidth / SquareSize : 0\r\n    let SquarelinesWidth = []\r\n    for(let i = 0; i <numofSquaresWidth ; i++){\r\n        SquarelinesWidth.push(i)\r\n    }\r\n\r\n    if(Outerdiv){\r\n       // console.log(Outerdiv.offsetWidth ,Outerdiv.offsetHeight )\r\n    }\r\n   \r\n    return(    \r\n        <Grid container>\r\n            <Grid item xs = {12}>\r\n            <Stage ref={setStageRef}\r\n                width = {Outerdiv ? Outerdiv.offsetWidth : 0}\r\n                height = {Outerdiv ? Outerdiv.offsetHeight : 0}\r\n                onMouseDown = {onMouseDown}\r\n                onMouseMove = {onMouseMove}\r\n                onMouseUp = {onMouseUp}\r\n               > \r\n                        <Layer>\r\n                            {Outerdiv ?\r\n                            Squarelines.map(number => {\r\n                                return(\r\n                                    <React.Fragment>\r\n                                        <Line points = {[0,(SquareSize)*number,Outerdiv.offsetWidth ,(SquareSize)*number]}  strokeWidth={2}  stroke= 'lightgrey'/>                     \r\n                                    </React.Fragment>                              \r\n                                )\r\n                            }) : <></>}\r\n                             {Outerdiv ?\r\n                            SquarelinesWidth.map(number => {\r\n                                return(\r\n                                    <React.Fragment>\r\n                                        <Line points = {[(Outerdiv.offsetWidth/numofSquaresWidth)*number,0,(Outerdiv.offsetWidth/numofSquaresWidth)*number ,Outerdiv.offsetHeight]}  strokeWidth={2}  stroke= 'lightgrey'/>                                          \r\n                                    </React.Fragment>                              \r\n                                )\r\n                            }) : <></>}\r\n                        </Layer>\r\n                        <Layer>\r\n                       \r\n                            <Line                                                        \r\n                                id = {currentLine ? currentLine.id : 0}\r\n                                points = {currentLine ? [currentLine.x0 ,currentLine.y0 , currentLine.x , currentLine.y ] : []}                   \r\n                                strokeWidth={2}\r\n                                stroke= 'black'                            \r\n                                />                           \r\n\r\n                                {lines.map((line, index) => (\r\n                                    <Line\r\n                                    {...line}               \r\n                                    strokeWidth={2}\r\n                                    stroke= 'black'               \r\n                                    />\r\n                                ))}\r\n                                <Rect\r\n                                    {...currentRect}\r\n                                    strokeWidth={2}\r\n                                    stroke= 'black'\r\n                                />\r\n                                {currentRect ?           \r\n                                <Text text = {Math.floor(Math.abs(currentRect.width/2))/proportion} x = {currentRect.xDirection = 'right' ? currentRect.x + (currentRect.width / 2) : (currentRect.x - (currentRect.width / 2))} y={currentRect.y} fontSize = {20} /> \r\n                                :\r\n                                <></> }\r\n                                {currentRect ?           \r\n                                <Text text = {Math.floor(Math.abs(currentRect.height/2))/proportion} x = {currentRect.x} y={currentRect.xDirection = 'up' ? currentRect.y + (currentRect.height / 2) : (currentRect.y - (currentRect.height / 2))} fontSize = {20} /> \r\n                                :\r\n                                <></> }\r\n                                {props.Rectangles.map((rect, index) => (\r\n                                    <Rectangle\r\n                                    shapeProps = {rect}       \r\n                                    key = {index}               \r\n                                    isSelected={rect.id === selectedId}\r\n                                    onSelect={() => {\r\n                                      props.ChangeMode(null)\r\n                                      selectShape(rect.id);               \r\n                                    }}\r\n                                    onChange={(newAttrs) => {\r\n                                      const Rectangles = props.Rectangles.slice();\r\n                                      props.Rectangles[index] = newAttrs;                                    \r\n                                      props.UpdateRectangles(props.Rectangles)\r\n                                   \r\n                                    }}\r\n                                    />\r\n                                ))}     \r\n\r\n                                {props.Rectangles.map((rect, index) => (                                          \r\n                                        <Text text = {Math.floor(Math.abs(rect.width/2))/proportion} x = {rect.xDirection = 'right' ? rect.x + (rect.width / 2) : (rect.x - (rect.width / 2))} y={rect.y} fontSize = {20} />\r\n                                    \r\n                                ))}  \r\n                                {props.Rectangles.map((rect, index) => (                                                              \r\n                                        <Text text = {Math.floor(Math.abs(rect.height/2))/proportion} x = {rect.x} y={rect.xDirection = 'up' ? rect.y + (rect.height / 2) : (rect.y - (rect.height / 2))} fontSize = {20} />                     \r\n                                ))}       \r\n                       \r\n                             \r\n\r\n                                 <Circle\r\n                                 {...currentCircle}\r\n                                 strokeWidth={2}\r\n                                stroke= 'black'/>\r\n                                {currentCircle ?\r\n                                <Text text= {Math.floor(currentCircle.radius)/proportion} x = {currentCircle.x} y = {currentCircle.y} fontSize = {currentCircle.radius < 20 ? 15 : 20}/>:\r\n                                <></>}\r\n                                \r\n                                {props.Circles.map((circle , index) => {\r\n                                    return(\r\n                                       <Circular \r\n                                       shapeProps = {circle}\r\n                                       key = {index}\r\n                                       isSelected= {circle.id === selectedcircleId}\r\n                                       onSelect={() => {\r\n                                           props.ChangeMode(null)   \r\n                                           setSelectedcircleId(circle.id)   \r\n                                           selectShape(null)      \r\n                                         }}\r\n                                         onChange={(newAttrs) => {\r\n                                            const Circles = props.Circles.slice();\r\n                                            props.Circles[index] = newAttrs;                                         \r\n                                            props.UpdateCircles(props.Circles)                                                                                  \r\n                                         }}\r\n                                       />)\r\n                                       \r\n                                })}\r\n\r\n\r\n                                {props.Circles.map((circle , index) => {\r\n                                    return(\r\n                                     <Text text= {Math.floor(circle.radius)/proportion/2} x = {circle.x} y = {circle.y} fontSize = {circle.radius < 20 ? 15 : 20}/>\r\n                                    )\r\n                                })}\r\n                                \r\n\r\n\r\n                        \r\n                            <Line\r\n                                points={flattenedPoints}\r\n                                stroke=\"black\"\r\n                                strokeWidth={2}\r\n                                closed={isFinished}\r\n                            />\r\n                            {props.points.map((point, index) => {\r\n                                const width = 6;\r\n                                const x = point[0] - width / 2;\r\n                                const y = point[1] - width / 2;\r\n                                const startPointAttr =\r\n                                index === 0\r\n                                    ? {\r\n                                        hitStrokeWidth: 12,\r\n                                        onMouseOver: handleMouseOverStartPoint,\r\n                                        onMouseOut: handleMouseOutStartPoint\r\n                                    }\r\n                                    : null;\r\n                                return (\r\n                                <Rect\r\n                                    key={index}\r\n                                    x={x}\r\n                                    y={y}\r\n                                    width={width}\r\n                                    height={width}\r\n                                    fill=\"white\"\r\n                                    stroke=\"black\"\r\n                                    strokeWidth={3}\r\n                                    onDragStart={handleDragStartPoint}\r\n                                    onDragMove={handleDragMovePoint}\r\n                                    onDragEnd={handleDragEndPoint}\r\n                                    draggable\r\n                                    {...startPointAttr}\r\n                                />\r\n                                );\r\n                                })}\r\n                               \r\n                                {flattenedPoints.map((point, index) => {    \r\n                                let x = -500\r\n                                let y = -500\r\n                                let x1 = flattenedPoints[index+2]\r\n                                let y1 = flattenedPoints[index+3]\r\n                                if(index % 2 === 0 && index +3 < flattenedPoints.length){                                  \r\n                                     x = (point + flattenedPoints[index+2]) / 2;\r\n                                     y = (flattenedPoints[index+1] + flattenedPoints[index+3]) / 2;  \r\n                                }                                 \r\n                                return (\r\n                                    index % 2 === 0 ?\r\n                                    <Text text={(parseFloat((PitagorasSentence(x,y,x1,y1))) / proportion).toFixed(2)} x={x} y={y} fontSize={20} /> : \r\n                                    <></>\r\n                                );\r\n                                })}\r\n                            \r\n\r\n                            {props.Polygons.map((poly , index) =>{       \r\n                             return(     \r\n                                 <>                \r\n                                  {/* <Line\r\n                                  points={poly.flattenedPoints}\r\n                                  stroke=\"black\"\r\n                                  strokeWidth={2}\r\n                                  closed={poly.closed}\r\n                              /> */}\r\n                                {poly.anchorPoints.map((point, index) => {  \r\n                                    return(\r\n                                    <>\r\n                                      <Shape\r\n                                      sceneFunc={(context, shape) => {\r\n                                         context.beginPath();\r\n                                         if(poly.points[index] && poly.points[index+1]){\r\n                                         context.moveTo(poly.points[index][0] , poly.points[index][1]);\r\n                                         context.quadraticCurveTo(point[0] , point[1],poly.points[index+1][0] ,poly.points[index+1][1]);\r\n                                         }\r\n                                         else{\r\n                                             if(index === poly.points.length-1){\r\n                                                context.moveTo(poly.points[index][0] , poly.points[index][1]);\r\n                                                context.quadraticCurveTo(point[0] , point[1],poly.points[0][0] ,poly.points[0][1]);\r\n                                             }\r\n                                         }\r\n                                         // (!) Konva specific method, it is very important\r\n                                         context.fillStrokeShape(shape);\r\n                                         }}\r\n                                         stroke=\"black\"\r\n                                         strokeWidth={4}/>\r\n                                         <Line\r\n                                         dash= {[10, 10, 0, 10]}\r\n                                         strokeWidth= {3}\r\n                                         stroke='red'\r\n                                         lineCap='round'\r\n                                         id='quadLinePath'\r\n                                         opacity= {0.3}\r\n                                         points= {poly.points[index] && poly.points[index+1] ? [poly.points[index][0] , poly.points[index][1],point[0] , point[1],poly.points[index+1][0] ,poly.points[index+1][1]] : [poly.points[index][0] , poly.points[index][1],point[0] , point[1],poly.points[0][0] ,poly.points[0][1]]}/>\r\n                                         <Line\r\n                                            dash= {[10, 10, 0, 10]}\r\n                                            strokeWidth= {3}\r\n                                            stroke='grey'\r\n                                            lineCap='round'\r\n                                            id='quadLinePath'\r\n                                            opacity= {0.3}\r\n                                            points = {poly.points[index] && poly.points[index+1] ? [poly.points[index][0] , poly.points[index][1],poly.points[index+1][0] ,poly.points[index+1][1]] : [poly.points[index][0] , poly.points[index][1],poly.points[0][0] ,poly.points[0][1]]}\r\n                                         />\r\n                                     </>\r\n                                 \r\n                                    )    \r\n                                })}\r\n                        \r\n                                {poly.points.map((point, index) => {\r\n                                   \r\n                                    const width = 6;\r\n                                    const x = point[0] - width / 2;\r\n                                    const y = point[1] - width / 2;\r\n                                    const startPointAttr =\r\n                                    index === 0\r\n                                        ? {\r\n                                            hitStrokeWidth: 12,\r\n                                            onMouseOver: handleMouseOverStartPoint,\r\n                                            onMouseOut: handleMouseOutStartPoint\r\n                                        }\r\n                                        : null;\r\n                                    return (\r\n                                    props.mode === 'Polygon' ?                                   \r\n                                    <Rect\r\n                                        key={index}\r\n                                        x={x}\r\n                                        y={y}\r\n                                        width={width}\r\n                                        height={width}\r\n                                        fill=\"white\"\r\n                                        stroke=\"#B6D4F8\"\r\n                                        strokeWidth={3}\r\n                                        onDragStart={handleDragStartPoint}\r\n                                        onDragMove={handleDragMovePoint}\r\n                                        onDragEnd={handleDragEndPoint}\r\n                                        draggable\r\n                                        {...startPointAttr}\r\n                                    /> : <></>\r\n                                    );\r\n                                })}\r\n                                 {poly.flattenedPoints.map((point, index) => {    \r\n                                    let x = -500\r\n                                    let y = -500\r\n                                    let x1 = poly.flattenedPoints[index+2]\r\n                                    let y1 = poly.flattenedPoints[index+3]\r\n                                    if(index % 2 === 0 && index +3 < poly.flattenedPoints.length){                                  \r\n                                        x = (point + poly.flattenedPoints[index+2]) / 2;\r\n                                        y = (poly.flattenedPoints[index+1] + poly.flattenedPoints[index+3]) / 2;  \r\n                                    }                                 \r\n                                    return (\r\n                                        index % 2 === 0?\r\n                                        <Text text={(parseFloat((PitagorasSentence(x,y,x1,y1))) / proportion).toFixed(2)} x={x} y={y} fontSize={20} /> : \r\n                                        <></>\r\n                                    );\r\n                                    })}\r\n                                  {poly.anchorPoints.map((point, index) => {\r\n                                   const width = 6;\r\n                                   const x = point[0] - width / 2;\r\n                                   const y = point[1] - width / 2;\r\n                                   const startPointAttr =\r\n                                   index === 0\r\n                                       ? {\r\n                                           hitStrokeWidth: 12,\r\n                                           onMouseOver: handleMouseOverStartPoint,\r\n                                           onMouseOut: handleMouseOutStartPoint\r\n                                       }\r\n                                       : null;\r\n                                   return (\r\n                                   props.mode === 'Polygon' ?                                   \r\n                                   <Rect\r\n                                       key={index}\r\n                                       x={x}\r\n                                       y={y}\r\n                                       width={width}\r\n                                       height={width}\r\n                                       fill=\"white\"\r\n                                       stroke=\"#B6D4F8\"\r\n                                       strokeWidth={3}\r\n                                       onDragStart={handleDragStartPoint}\r\n                                       onDragMove={handleDragMovePoint}\r\n                                       onDragEnd={handleDragEndPoint}\r\n                                       draggable\r\n                                       {...startPointAttr}\r\n                                   /> : <></>\r\n                                   );\r\n                               })}\r\n                                </>)\r\n                            })}\r\n\r\n                    \r\n                      \r\n                      </Layer>  \r\n                        \r\n            </Stage>   \r\n            </Grid>           \r\n        </Grid>\r\n    )\r\n    \r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        mode : state.konva.mode,\r\n        stage : state.konva.stage,\r\n        stateStack : state.konva.stateStack,\r\n        Polygons : state.konva.Polygons,\r\n        Rectangles : state.konva.Rectangles,\r\n        Circles : state.konva.Circles, \r\n        points : state.konva.points,\r\n        proportion : state.konva.proportion,\r\n        accuracy : state.konva.accuracy\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        ChangeHeight : (newHeight) => dispatch({type : 'ChangeHeight' , newHeight : newHeight}),\r\n        ChangeMode: (newMode) => dispatch({type : 'ChangeMode' , newMode : newMode}),\r\n        ChangeStage: (newStage) => dispatch({type : 'ChangeStage' , newStage : newStage}),\r\n        UpdateCircles : (newCircles) => dispatch({type : 'UpdateCircles' , newCircles : newCircles}),\r\n        UpdatePolygons : (newPolygons) => dispatch({type : 'UpdatePolygons' , newPolygons : newPolygons}),\r\n        UpdateRectangles : (newRectangles) => dispatch({type : 'UpdateRectangles' , newRectangles : newRectangles}),\r\n        actionTrigger : () => dispatch({type : 'actionTrigger'}),\r\n        AddPoint : (Point) => dispatch({type : 'AddPoint' , newPoint : Point}),\r\n        emptyPoints : () => dispatch({type : 'emptyPoints'}),\r\n        Undo : () => dispatch({type: 'Undo'})\r\n    }\r\n}\r\n\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(KonvaContainer)","import React, { Component } from \"react\";\r\nimport Konva from \"konva\";\r\nimport { render } from \"react-dom\";\r\nimport { Stage, Layer, Group, Line, Rect } from \"react-konva\";\r\n\r\nclass Polygon extends Component {\r\n  state = {\r\n    points: [],\r\n    curMousePos: [0, 0],\r\n    isMouseOverStartPoint: false,\r\n    isFinished: false\r\n  };\r\n \r\n  componentDidMount() {\r\n    console.log(window.innerHeight);\r\n  }\r\n\r\n  getMousePos = stage => {\r\n    return [stage.getPointerPosition().x, stage.getPointerPosition().y];\r\n  };\r\n  handleClick = event => {\r\n    const {\r\n      state: { points, isMouseOverStartPoint, isFinished },\r\n      getMousePos\r\n    } = this;\r\n    const stage = event.target.getStage();\r\n    const mousePos = getMousePos(stage);\r\n\r\n    if (isFinished) {\r\n      return;\r\n    }\r\n    if (isMouseOverStartPoint && points.length >= 3) {\r\n      this.setState({\r\n        isFinished: true\r\n      });\r\n    } else {\r\n      this.setState({\r\n        points: [...points, mousePos]\r\n      });\r\n    }\r\n  };\r\n  handleMouseMove = event => {\r\n    const { getMousePos } = this;\r\n    const stage = event.target.getStage();\r\n    const mousePos = getMousePos(stage);\r\n\r\n    this.setState({\r\n      curMousePos: mousePos\r\n    });\r\n  };\r\n  handleMouseOverStartPoint = event => {\r\n    if (this.state.isFinished || this.state.points.length < 3) return;\r\n    event.target.scale({ x: 2, y: 2 });\r\n    this.setState({\r\n      isMouseOverStartPoint: true\r\n    });\r\n  };\r\n  handleMouseOutStartPoint = event => {\r\n    event.target.scale({ x: 1, y: 1 });\r\n    this.setState({\r\n      isMouseOverStartPoint: false\r\n    });\r\n  };\r\n  handleDragStartPoint = event => {\r\n    console.log(\"start\", event);\r\n  };\r\n  handleDragMovePoint = event => {\r\n    const points = this.state.points;\r\n    const index = event.target.index - 1;\r\n    console.log(event.target);\r\n    const pos = [event.target.attrs.x, event.target.attrs.y];\r\n    console.log(\"move\", event);\r\n    console.log(pos , \"pos\");\r\n    this.setState({\r\n      points: [...points.slice(0, index), pos, ...points.slice(index + 1)]\r\n    });\r\n  };\r\n  \r\n  handleDragOutPoint = event => {\r\n    console.log(\"end\", event);\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      state: { points, isFinished, curMousePos },\r\n      handleClick,\r\n      handleMouseMove,\r\n      handleMouseOverStartPoint,\r\n      handleMouseOutStartPoint,\r\n      handleDragStartPoint,\r\n      handleDragMovePoint,\r\n      handleDragEndPoint\r\n    } = this;\r\n    // [ [a, b], [c, d], ... ] to [ a, b, c, d, ...]\r\n    const flattenedPoints = points\r\n      .concat(isFinished ? [] : curMousePos)\r\n      .reduce((a, b) => a.concat(b), []);\r\n    return (\r\n        <Layer  onMouseDown={handleClick}\r\n              onMouseMove={handleMouseMove}>\r\n          <Line\r\n            points={flattenedPoints}\r\n            stroke=\"black\"\r\n            strokeWidth={5}\r\n            closed={isFinished}\r\n          />\r\n          {points.map((point, index) => {\r\n            const width = 6;\r\n            const x = point[0] - width / 2;\r\n            const y = point[1] - width / 2;\r\n            const startPointAttr =\r\n              index === 0\r\n                ? {\r\n                    hitStrokeWidth: 12,\r\n                    onMouseOver: handleMouseOverStartPoint,\r\n                    onMouseOut: handleMouseOutStartPoint\r\n                  }\r\n                : null;\r\n            return (\r\n              <Rect\r\n                key={index}\r\n                x={x}\r\n                y={y}\r\n                width={width}\r\n                height={width}\r\n                fill=\"white\"\r\n                stroke=\"black\"\r\n                strokeWidth={3}\r\n                onDragStart={handleDragStartPoint}\r\n                onDragMove={handleDragMovePoint}\r\n                onDragEnd={handleDragEndPoint}\r\n                draggable\r\n                {...startPointAttr}\r\n              />\r\n            );\r\n          })}\r\n        </Layer>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Polygon\r\n","import Polygon from \"../Components/Konva/copiedPolygon\"\r\n\r\nconst LineEquation = (x , y , x1 ,y1) => {\r\n    // slope of straight line = y-y1 / x-x1\r\n    if(x-x1 === 0){\r\n        return [Infinity, Infinity]\r\n    }\r\n    if(y-y1 === 0){\r\n        return [0 , y]\r\n    }\r\n    let slope = (y-y1) / (x-x1)\r\n    // equation of straight line = y= mx + b when b is constant\r\n    let constant = slope *(x1* -1) + y1\r\n    return [slope,constant]\r\n}\r\n\r\n\r\nconst PointsGenerator = (firstX , lastX, slope , constant) => {\r\n    //this function gets a range of X's between two points , and return an array of points with gap of 1\r\n    let PointsArray = []\r\n    if(firstX > lastX){\r\n        for(let currentX = firstX ; currentX >= lastX ; currentX--){\r\n            let currentY = slope*currentX + constant\r\n            PointsArray = [...PointsArray , [currentX , currentY]]\r\n        }\r\n    }\r\n    else {\r\n        for(let currentX = firstX ; currentX <= lastX ; currentX++){\r\n            let currentY = slope*currentX + constant\r\n            PointsArray = [...PointsArray , [currentX , currentY]]\r\n        }\r\n    }\r\n    return PointsArray\r\n}\r\n\r\n\r\nconst indexOfPoint = (point , Points) => {\r\n    // returns the index of certain point\r\n    for(let index = 0 ; index < Points.length ; index++){\r\n        if(Points[index][0] === point[0] && Points[index][1] === point[1]){\r\n            return index\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nconst removeUselessPoints=  (PolygonPoints) => {\r\n    //this function gets polygon points and remove useless one which means they are not part of the polygon\r\n    let beforePointEquation = []\r\n    let afterPointEquation = []\r\n    let PointsToSplice = []\r\n    let CopyPoints = [...PolygonPoints]\r\n    for(let point = 0 ; point < PolygonPoints.length ; point++){\r\n        if(point === 0){\r\n            beforePointEquation = LineEquation(PolygonPoints[PolygonPoints.length -1][0] ,PolygonPoints[PolygonPoints.length -1][1] , PolygonPoints[point][0] , PolygonPoints[point][1])\r\n            afterPointEquation = LineEquation(PolygonPoints[point][0] ,PolygonPoints[point][1] , PolygonPoints[point+1][0] , PolygonPoints[point+1][1])\r\n        }\r\n        else{\r\n            if(point === PolygonPoints.length -1){\r\n                beforePointEquation = LineEquation(PolygonPoints[point-1][0] ,PolygonPoints[point-1][1] , PolygonPoints[point][0] , PolygonPoints[point][1])\r\n                afterPointEquation = LineEquation(PolygonPoints[point][0] ,PolygonPoints[point][1] , PolygonPoints[0][0] , PolygonPoints[0][1])\r\n            }\r\n            else{\r\n                beforePointEquation = LineEquation(PolygonPoints[point-1][0] ,PolygonPoints[point-1][1] , PolygonPoints[point][0] , PolygonPoints[point][1])\r\n                afterPointEquation = LineEquation(PolygonPoints[point][0] ,PolygonPoints[point][1] , PolygonPoints[point+1][0] , PolygonPoints[point+1][1])\r\n            }\r\n        }     \r\n        if(beforePointEquation[0] === afterPointEquation[0]){\r\n            PointsToSplice.push(point)\r\n        }\r\n      \r\n    }\r\n    PointsToSplice = [...new Set(PointsToSplice)]\r\n    for(let i = 0 ; i < PointsToSplice.length ; i++){\r\n        CopyPoints.splice(PointsToSplice[i] - i , 1)\r\n    }\r\n    return CopyPoints\r\n\r\n}\r\n\r\n\r\n// const ShapeSplitter = (StartPoint, EndPoint , OriginShapePoints) => {\r\n//     // this function get a big shape and coordinates of line crossing it and return the splitted shapes\r\n//     let StartIndex = indexOfPoint(StartPoint , OriginShapePoints)\r\n//     let EndIndex = indexOfPoint(EndPoint ,OriginShapePoints)\r\n//     let FirstShape = []\r\n//     let SecondShape = []\r\n//     let LineConstants = LineEquation(OriginShapePoints[EndIndex][0] , OriginShapePoints[EndIndex][1] , OriginShapePoints[StartIndex][0] , OriginShapePoints[StartIndex][1])\r\n//     for(let point = StartIndex+1 ; point < EndIndex ; point++){\r\n//         FirstShape = [...FirstShape , OriginShapePoints[point]]\r\n//     }\r\n//     FirstShape = [...FirstShape , ...PointsGenerator(OriginShapePoints[EndIndex][0] , OriginShapePoints[StartIndex][0] , LineConstants[0] , LineConstants[1])]\r\n//     for(let point = EndIndex+1 ; point < OriginShapePoints.length ; point++){\r\n//         SecondShape = [...SecondShape , OriginShapePoints[point]]\r\n//     }\r\n//     for(let point = 0; point < StartIndex ; point++){\r\n//         SecondShape = [...SecondShape , OriginShapePoints[point]]\r\n//     }\r\n//     SecondShape = [...SecondShape , ...PointsGenerator(OriginShapePoints[StartIndex][0] , OriginShapePoints[EndIndex][0] , LineConstants[0] , LineConstants[1])]\r\n//     return [FirstShape , SecondShape]\r\n// }\r\n\r\nconst ShapeSplitter = (StartPoint, EndPoint , OriginShapePoints) => {\r\n    // this function get a big shape and coordinates of line crossing it and return the splitted shapes\r\n    console.log(StartPoint, EndPoint , OriginShapePoints , 'shapeSplitterCords')\r\n    let StartIndex = indexOfPoint(StartPoint , OriginShapePoints)\r\n    let EndIndex = indexOfPoint(EndPoint ,OriginShapePoints)\r\n    let FirstShape = []\r\n    let SecondShape = []\r\n    let LineConstants = LineEquation(OriginShapePoints[EndIndex][0] , OriginShapePoints[EndIndex][1] , OriginShapePoints[StartIndex][0] , OriginShapePoints[StartIndex][1])\r\n    for(let point = StartIndex ; point <= EndIndex ; point++){\r\n        FirstShape = [...FirstShape , OriginShapePoints[point]]\r\n    }\r\n   \r\n    for(let point = EndIndex ; point < OriginShapePoints.length ; point++){\r\n        SecondShape = [...SecondShape , OriginShapePoints[point]]\r\n    }\r\n    for(let point = 0; point <= StartIndex ; point++){\r\n        SecondShape = [...SecondShape , OriginShapePoints[point]]\r\n    }\r\n    console.log(removeUselessPoints(FirstShape) ,removeUselessPoints(SecondShape) , 'splitted Shapes')\r\n    return [removeUselessPoints(FirstShape) ,removeUselessPoints(SecondShape)]\r\n}\r\n\r\nexport default ShapeSplitter","\r\nimport convex from \"@turf/convex\";\r\nimport { coordAll } from \"@turf/meta\";\r\nimport centroid from \"@turf/centroid\";\r\nimport transformRotate from \"@turf/transform-rotate\";\r\nimport bearing from \"@turf/bearing\";\r\nimport envelope from \"@turf/envelope\";\r\nimport area from \"@turf/area\";\r\nimport distance from \"@turf/distance\";\r\nimport * as turf from 'turf/turf'\r\n\r\nconst smallestSurroundingRectangleByarea= (Points) => {\r\n    const turfPoints = tranformToTurfPoints(Points)\r\n    const convexHull = turfPoints;\r\n    const centroidCoords = centroid(convexHull);\r\n    const allHullCoords = coordAll(convexHull);\r\n\r\n    let minArea = Number.MAX_SAFE_INTEGER;\r\n    let resultPolygon = null;\r\n    resultPolygon = envelope(tranformToTurfPoints(allHullCoords))\r\n    return resultPolygon;\r\n  }\r\n\r\n\r\n  const tranformToTurfPoints = (Points) => {\r\n    let turfPoints = []\r\n    for(let point = 0 ; point < Points.length ; point++){\r\n        turfPoints = [...turfPoints , turf.point([Points[point][0] , Points[point][1]])]\r\n    }\r\n    turfPoints = turf.featureCollection(turfPoints);\r\n    return turfPoints\r\n  }\r\n\r\n\r\nconst smallestSurroundingRectangleByareawithCurve = (Points) => {\r\n    const turfPoints = tranformToTurfPoints(Points)\r\n    const convexHull = turfPoints;\r\n   \r\n    const centroidCoords = centroid(convexHull);\r\n   \r\n    const allHullCoords = coordAll(convexHull);\r\n \r\n\r\n    let minArea = Number.MAX_SAFE_INTEGER;\r\n    let resultPolygon = null;\r\n  \r\n    for (let index = 0; index < allHullCoords.length - 1; index++) {\r\n      let angle = bearing(allHullCoords[index], allHullCoords[index + 1]);\r\n  \r\n      let rotatedHull = transformRotate(convexHull, -1.0 * angle, {\r\n        pivot: centroidCoords,\r\n      });\r\n  \r\n      let envelopeOfHull = envelope(rotatedHull);\r\n      let envelopeArea = area(envelopeOfHull);\r\n      if (envelopeArea < minArea) {\r\n        minArea = envelopeArea;\r\n        resultPolygon = transformRotate(envelopeOfHull, angle, {\r\n          pivot: centroidCoords,\r\n        });\r\n      }\r\n    }\r\n\r\n    return resultPolygon;\r\n  }\r\n\r\n\r\n \r\n\r\n  export default smallestSurroundingRectangleByarea","import { PhonelinkRingSharp } from \"@material-ui/icons\"\r\n\r\n\r\nconst LineEquation = (x , y , x1 ,y1) => {\r\n    // slope of straight line = y-y1 / x-x1\r\n    let slope = (y-y1) / (x-x1)\r\n    // equation of straight line = y= mx + b when b is constant\r\n    let constant = slope *(x1* -1) + y1\r\n    return [slope,constant]\r\n}\r\n\r\nconst CheckSegmentsIntersect = (Startpoint,EndPoint , Line) => {\r\n    // check if two segments of line intersects\r\n   // console.log(Startpoint, EndPoint , Line , 'intersectdata')\r\n    let constants = LineEquation(Startpoint[0], Startpoint[1] , EndPoint[0] , EndPoint[1])\r\n    let CrossX, CrossY\r\n    if(Math.abs(constants[0]) === Infinity && Math.abs(Line[0][0]) === Infinity ){\r\n        if(Startpoint[0] === Line[1][0]){\r\n            return false\r\n        }\r\n        else{\r\n            return false\r\n        }\r\n    }\r\n    if(constants[0] === Infinity || constants[0] === -Infinity){\r\n        CrossY = Line[1][1]\r\n        CrossX = Startpoint[0]\r\n        if(Math.abs(Line[0][0]) === 0){\r\n            if(Math.min(Line[1][0],Line[1][2]) < Startpoint[0] && Math.max(Line[1][0],Line[1][2]) > Startpoint[0] && (Line[1][1] < Math.max(Startpoint[1],EndPoint[1]) && Line[1][1] > Math.min(Startpoint[1],EndPoint[1]))){\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n    }\r\n    else{\r\n        if(Line[0][0] === Infinity || Line[0][0] === -Infinity){\r\n            CrossY =  Startpoint[1]\r\n            CrossX =  Line[1][0]          \r\n        }\r\n        else{\r\n            CrossX = (constants[1] - Line[0][1]) / (Line[0][0] - constants[0])\r\n            CrossY = constants[0]*CrossX + constants[1]\r\n            CrossX = parseFloat(CrossX.toFixed(2))\r\n            CrossY = parseFloat(CrossY.toFixed(2))\r\n            let maxXLine = parseFloat(Math.max(Line[1][0] , Line[1][2]).toFixed(2))\r\n            let maxYLine = parseFloat(Math.max(Line[1][1] , Line[1][3]).toFixed(2))\r\n            let maxXNewLine = parseFloat(Math.max(Startpoint[0] , EndPoint[0]).toFixed(2))\r\n            let maxYNewLine = parseFloat(Math.max(Startpoint[1] , EndPoint[1]).toFixed(2))\r\n            let minXLine = parseFloat(Math.min(Line[1][0] , Line[1][2]).toFixed(2))\r\n            let minYLine = parseFloat(Math.min(Line[1][1] , Line[1][3]).toFixed(2))\r\n            let minXNewLine = parseFloat(Math.min(Startpoint[0] , EndPoint[0]).toFixed(2))\r\n            let minYNewLine = parseFloat(Math.min(Startpoint[1] , EndPoint[1]).toFixed(2))\r\n            if((CrossX <= maxXNewLine && CrossX < maxXLine) && (CrossX >= minXNewLine && CrossX >minXLine)){\r\n                if((CrossY <= maxYNewLine && CrossY < maxYLine) && (CrossY >= minYNewLine && CrossY >minYLine)){\r\n                    return true\r\n                }\r\n            }\r\n            return false\r\n        }\r\n    }\r\n    CrossX = parseFloat(CrossX.toFixed(2))\r\n    CrossY = parseFloat(CrossY.toFixed(2))\r\n    let maxXLine = parseFloat(Math.max(Line[1][0] , Line[1][2]).toFixed(2))\r\n    let maxYLine = parseFloat(Math.max(Line[1][1] , Line[1][3]).toFixed(2))\r\n    let maxXNewLine = parseFloat(Math.max(Startpoint[0] , EndPoint[0]).toFixed(2))\r\n    let maxYNewLine = parseFloat(Math.max(Startpoint[1] , EndPoint[1]).toFixed(2))\r\n    let minXLine = parseFloat(Math.min(Line[1][0] , Line[1][2]).toFixed(2))\r\n    let minYLine = parseFloat(Math.min(Line[1][1] , Line[1][3]).toFixed(2))\r\n    let minXNewLine = parseFloat(Math.min(Startpoint[0] , EndPoint[0]).toFixed(2))\r\n    let minYNewLine = parseFloat(Math.min(Startpoint[1] , EndPoint[1]).toFixed(2))\r\n    if((CrossX <= maxXNewLine && CrossX <= maxXLine) && (CrossX >= minXNewLine && CrossX >= minXLine)){\r\n        if((CrossY <= maxYNewLine && CrossY <= maxYLine) && (CrossY >= minYNewLine && CrossY >= minYLine)){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n   \r\n}\r\n\r\nconst CheckIfLineInPoly = (Startpoint,EndPoint ,AllLines , AllPoints) => {\r\n    // checks if certain line is inside a polygon or also going outside of it\r\n    let intersectionsCounter = 0\r\n  \r\n    for(let line = 0 ; line < AllLines.length ; line++){\r\n        if(CheckSegmentsIntersect(Startpoint, EndPoint , AllLines[line])){\r\n          \r\n            intersectionsCounter++\r\n        }\r\n    }\r\n    if(intersectionsCounter >= 2){\r\n        return false\r\n    }\r\n    if(!CheckIfPointInPolygon((Startpoint[0]+EndPoint[0])/2 ,(Startpoint[1]+EndPoint[1])/2  , AllPoints)){\r\n        return false\r\n    }\r\n \r\n    return true\r\n}\r\n\r\nconst CheckIfPointInPolygon = (x,y , BasePoints) => {\r\n    //check if a specific point is inside or outside a polygon\r\n    let point = BasePoints[0]\r\n    let point2 = []\r\n    let counter = 0\r\n    for (let i=1;i<=BasePoints.length;i++) {\r\n        point2 = BasePoints[i % BasePoints.length];\r\n        if (y >  Math.min(point[1],point2[1])) {\r\n          if (y <= Math.max(point[1],point2[1])) {\r\n            if (x <= Math.max(point[0],point2[0])) {\r\n              if (point[1] != point2[1]) {\r\n                let xinters = (y-point[1])*(point2[0]-point[0])/(point2[1]-point[1])+point[0];\r\n                if (point[0] == point2[0] || x <= xinters)\r\n                  counter++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        point = point2;\r\n      }\r\n    \r\n    if (counter % 2 == 0){\r\n    return(false);\r\n    }\r\n    else{\r\n    return(true);\r\n    }   \r\n}\r\n\r\nconst indexOfPoint = (point , Points) => {\r\n    // returns the index of certain point\r\n    for(let index = 0 ; index < Points.length ; index++){\r\n        if(Points[index][0] === point[0] && Points[index][1] === point[1]){\r\n            return index\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nconst CheckIfLineInShape = (x,y,x1,y1,BasePoints) => {\r\n    //this function gets two points and checks if the line between them is inside or outside the shape\r\n    let constants = LineEquation(x,y,x1,y1);\r\n    let startX = Math.min(x,x1)\r\n    let endX = Math.max(x,x1)\r\n    if(Math.abs(x-x1) > Math.abs(y-y1)){\r\n        for(let currentX = startX+1 ; currentX < endX ; currentX++){\r\n            let currentY = constants[0]*currentX + constants[1]\r\n            if(CheckIfPointInPolygon(currentX , currentY , BasePoints) === false){              \r\n                return false\r\n            }\r\n            else{               \r\n            }\r\n        }\r\n    }\r\n    else{\r\n        let startY = Math.min(y,y1)\r\n        let endY = Math.max(y,y1)\r\n        let CurrentX = 0\r\n        for(let CurrentY = startY+1 ; startY < endY ; CurrentY++){\r\n            if(x === x1){\r\n                CurrentX = x\r\n            }\r\n            else{\r\n                CurrentX = (CurrentY - constants[1])/constants[0]\r\n            }        \r\n            if(CheckIfPointInPolygon(CurrentX , CurrentY , BasePoints) === false){\r\n                return false\r\n            }\r\n            else{\r\n            }\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\n\r\nconst FilterNotPossibleDots = (index , Points) => {\r\n    // filter the adjacent points and the point itself taking care of limit of array   \r\n    let CopyPoints = [...Points]\r\n    let rightAdjacent  = []\r\n    let leftAdjacent = []\r\n    let PointsToSplice = []\r\n    if(index === 0){\r\n         rightAdjacent = CopyPoints[1]\r\n         leftAdjacent = CopyPoints[CopyPoints.length -1] \r\n    }\r\n    else{\r\n    if(index === CopyPoints.length-1){\r\n         rightAdjacent = CopyPoints[0]\r\n         leftAdjacent = CopyPoints[CopyPoints.length -2]\r\n    }\r\n    else{        \r\n            rightAdjacent = CopyPoints[index-1]\r\n            leftAdjacent = CopyPoints[index+1]      \r\n    }\r\n    }     \r\n    let rightConstants = LineEquation(CopyPoints[index][0] , CopyPoints[index][1], rightAdjacent[0] , rightAdjacent[1]) \r\n    let leftConstants = LineEquation(CopyPoints[index][0] , CopyPoints[index][1], leftAdjacent[0] , leftAdjacent[1])\r\n    for(let currentPoint = 0 ; currentPoint <  Points.length ; currentPoint++){ \r\n        if(Points[index][0] === rightAdjacent[0]){\r\n            if(Points[currentPoint][0] === Points[index][0]){\r\n                PointsToSplice.push(currentPoint)\r\n            }\r\n        }    \r\n        else{\r\n            if(Points[currentPoint][1] - ((rightConstants[0] *Points[currentPoint][0]) + rightConstants[1]) < 0.05 && Points[currentPoint][1] - ((rightConstants[0] *Points[currentPoint][0]) + rightConstants[1]) > -0.05){\r\n                PointsToSplice.push(currentPoint)\r\n            }      \r\n        }\r\n        if(Points[index][0] === leftAdjacent[0]){\r\n            if(Points[currentPoint][0] === Points[index][0]){\r\n                PointsToSplice.push(currentPoint)\r\n            }\r\n        }  \r\n        else{  \r\n            if(Points[currentPoint][1] - ((leftConstants[0] *Points[currentPoint][0]) + leftConstants[1]) < 0.05 && Points[currentPoint][1] - ((leftConstants[0] *Points[currentPoint][0]) + leftConstants[1]) > -0.05){\r\n                PointsToSplice.push(currentPoint)\r\n            }\r\n        }\r\n    }\r\n    PointsToSplice = [...new Set(PointsToSplice)]\r\n    for(let i = 0 ; i < PointsToSplice.length ; i++){\r\n        CopyPoints.splice(PointsToSplice[i] - i , 1)\r\n    }\r\n    return CopyPoints\r\n}\r\n\r\n\r\nconst LineLength = (x,y,constants , LinePoints , crossingPoint) => {\r\n    if(constants[0] === Infinity || constants[0] === -Infinity ){     \r\n        return Math.abs(x - LinePoints[0])\r\n    }\r\n    if(constants[0] === -0 || constants[0] === 0){\r\n        return Math.abs(y-LinePoints[1])\r\n    }\r\n    return (Math.sqrt(Math.pow(x - crossingPoint[0] , 2) + Math.pow(y - crossingPoint[1] , 2)))\r\n}\r\n\r\n\r\nconst getAllStraightEquations = (BasePoints) => {\r\n    // gets all the straight Lines from the polygon\r\n    let straightLines = []\r\n    for(let point = 0 ; point < BasePoints.length-1 ; point++){\r\n        let constants = LineEquation(BasePoints[point][0],BasePoints[point][1],BasePoints[point+1][0],BasePoints[point+1][1])\r\n        if(constants[0] === Infinity || constants[0] === -Infinity) {\r\n            straightLines = [...straightLines , [[Infinity ,BasePoints[point+1][0]] ,[BasePoints[point][0],BasePoints[point][1],BasePoints[point+1][0],BasePoints[point+1][1]] ]]\r\n        }\r\n        else{\r\n            straightLines = [...straightLines , [LineEquation(BasePoints[point][0],BasePoints[point][1],BasePoints[point+1][0],BasePoints[point+1][1]) , [BasePoints[point][0],BasePoints[point][1],BasePoints[point+1][0],BasePoints[point+1][1]]]]\r\n        }   \r\n    }\r\n    straightLines = [...straightLines , [LineEquation(BasePoints[BasePoints.length-1][0],BasePoints[BasePoints.length-1][1],BasePoints[0][0],BasePoints[0][1]), [BasePoints[BasePoints.length-1][0],BasePoints[BasePoints.length-1][1],BasePoints[0][0],BasePoints[0][1]]]]\r\n    return straightLines\r\n}\r\n\r\n\r\nconst getCrossPointBetweenTwoLines = (FirstConstants , SecondConstants , plumbPoint , LinePoints) => {\r\n    let x  =0\r\n    let y =0\r\n    if(SecondConstants[0] === Infinity || SecondConstants[0] === -Infinity){\r\n         x = LinePoints[0]\r\n         y = plumbPoint[1]\r\n         return [x,y]\r\n    }\r\n    else{\r\n        if(SecondConstants[0] === 0 || SecondConstants[0] === -0){\r\n            x = plumbPoint[0]\r\n            y = LinePoints[1]\r\n            return [x,y]\r\n        }\r\n    }\r\n    x = (SecondConstants[1] - FirstConstants[1]) / (FirstConstants[0] - SecondConstants[0])\r\n    y = FirstConstants[0]*x + FirstConstants[1]\r\n    return [x,y]\r\n}\r\n\r\nconst filterStraightLines = (Point, PolygonStraightEquations) => {\r\n    // get point and filter only the possible lines in the shape\r\n    let filteredLines = []\r\n    let plumbConstants = []\r\n    let crossPoint = []\r\n    for(let line = 0 ; line < PolygonStraightEquations.length ; line++){\r\n        //if the slope of the line is infinity than it means its from x= ? type than its plumb will be y = ? \r\n       \r\n        if(PolygonStraightEquations[line][0][0] !== Infinity){\r\n            if(PolygonStraightEquations[line][0][0] !== -0 || PolygonStraightEquations[line][0][0] !== 0){\r\n                let slope = -(1/PolygonStraightEquations[line][0][0])\r\n                plumbConstants = [slope, Point[1] - (slope* Point[0])]\r\n            }\r\n            // if the line is from kind y = ? than the plumb slope is infinity and his b doesnt exist because he is x= ? type\r\n            else{\r\n                 plumbConstants = [Infinity , NaN]\r\n            }\r\n            // if the line is x= ? then the x of cross point is constant and the y is one of the y's on the plumb line\r\n            if(plumbConstants[0] === Infinity){\r\n                crossPoint = [Point[0] , PolygonStraightEquations[line][1][1]]\r\n            }\r\n            // else if its regular line than calculate the point regulary\r\n            else{\r\n                crossPoint = getCrossPointBetweenTwoLines(plumbConstants ,PolygonStraightEquations[line][0] , Point ,PolygonStraightEquations[line][1] )\r\n            }\r\n            if(crossPoint[1] > Math.min(PolygonStraightEquations[line][1][1] ,PolygonStraightEquations[line][1][3]) && crossPoint[1] < Math.max(PolygonStraightEquations[line][1][1] ,PolygonStraightEquations[line][1][3])){\r\n                if(crossPoint[0] > Math.min(PolygonStraightEquations[line][1][0] ,PolygonStraightEquations[line][1][2]) && crossPoint[0] < Math.max(PolygonStraightEquations[line][1][0] ,PolygonStraightEquations[line][1][2])){                \r\n                    filteredLines.push(PolygonStraightEquations[line])\r\n                }\r\n            }\r\n            if(plumbConstants[0] === Infinity){\r\n                if(crossPoint[0] > Math.min(PolygonStraightEquations[line][1][0] ,PolygonStraightEquations[line][1][2]) && crossPoint[0] < Math.max(PolygonStraightEquations[line][1][0] ,PolygonStraightEquations[line][1][2])){                 \r\n                    filteredLines.push(PolygonStraightEquations[line])\r\n                }\r\n            }\r\n        }\r\n        if(PolygonStraightEquations[line][0][0] === Infinity){\r\n            if(Point[1] > Math.min(PolygonStraightEquations[line][1][1] ,PolygonStraightEquations[line][1][3]) && Point[1] < Math.max(PolygonStraightEquations[line][1][1] ,PolygonStraightEquations[line][1][3])){\r\n           \r\n                filteredLines.push(PolygonStraightEquations[line])\r\n            }\r\n        }\r\n    }\r\n    return filteredLines\r\n}\r\n\r\n\r\n\r\nconst GetLongestStraightLine = (BasePoints) => {\r\n    //this function get the ShapePoints from the DotsSpreading algorithm and return the longenst Line Possible in the Shape\r\n    let filteredPoints = []\r\n    let maxLength = 1000\r\n    let Points = []\r\n    let PolygonStraightEquations = getAllStraightEquations(BasePoints)\r\n\r\n    for(let point = 0 ; point < BasePoints.length ; point++)\r\n    {\r\n        let filteredStraightEquations = filterStraightLines(BasePoints[point] ,PolygonStraightEquations)\r\n        for(let line = 0 ; line < filteredStraightEquations.length; line++){\r\n            let slope =-1/filteredStraightEquations[line][0][0]\r\n            let crossingPoint = getCrossPointBetweenTwoLines([slope ,BasePoints[point][1] - ((slope) * (BasePoints[point][0]))] , filteredStraightEquations[line][0] , BasePoints[point] ,filteredStraightEquations[line][1])\r\n            if(CheckIfLineInPoly([BasePoints[point][0] ,BasePoints[point][1]] ,crossingPoint, PolygonStraightEquations , BasePoints)){\r\n              \r\n                if(LineLength(BasePoints[point][0] ,BasePoints[point][1],filteredStraightEquations[line][0] , filteredStraightEquations[line][1] , crossingPoint ) < maxLength){\r\n                    maxLength = LineLength(BasePoints[point][0] ,BasePoints[point][1],filteredStraightEquations[line][0] ,  filteredStraightEquations[line][1] , crossingPoint) \r\n                    let constants = []\r\n                    constants.push(slope)\r\n                    let n = BasePoints[point][1] - ((slope) * (BasePoints[point][0]))\r\n                    constants.push(n)\r\n                    Points = [BasePoints[point][0] , BasePoints[point][1], getCrossPointBetweenTwoLines( constants , filteredStraightEquations[line][0] , BasePoints[point] ,filteredStraightEquations[line][1] ) , indexOfPoint([filteredStraightEquations[line][1][0], filteredStraightEquations[line][1][1]] ,BasePoints )+1]\r\n                }     \r\n            }         \r\n        }\r\n        \r\n    }\r\n    return Points\r\n}\r\n\r\nexport default GetLongestStraightLine","import { Minimize } from \"@material-ui/icons\"\r\n\r\n\r\nconst MinimizeStrips = (CounterArray) => {\r\n    let minimizedArray = [0,0,0]\r\n    let twos =  CounterArray[0]\r\n    let threes =  CounterArray[1]   \r\n    twos = CounterArray[0]%2\r\n    threes = CounterArray[1]%4\r\n    let fours = (CounterArray[0]-twos)/2\r\n    fours += (CounterArray[1]-threes)/4  \r\n    fours += CounterArray[2]\r\n    minimizedArray[0] = twos\r\n    minimizedArray[1] = threes\r\n    minimizedArray[2] = fours\r\n    return minimizedArray\r\n}\r\n\r\nconst RectangleSplitter = (width ,  height) => {\r\n    console.log(width ,  height , 'measures')\r\n    let counterArray = [0,0,0]\r\n    let TempminimumWaste = 0\r\n    let FinalMinimumWaste =100\r\n    let remain = 0\r\n    let TempMinimumWidth = 0\r\n    let FinalCounterArray = []\r\n    if(height < 2){\r\n        counterArray[0] = 1\r\n        FinalMinimumWaste = 2 -height\r\n        return[counterArray ,FinalMinimumWaste ]\r\n    }\r\n    if(height > 2 && height <= 3){\r\n        counterArray[1] = 1\r\n        FinalMinimumWaste = 3 -height\r\n        return[counterArray ,FinalMinimumWaste ]\r\n    }\r\n    if(height > 3 && height <= 4){\r\n        counterArray[2] = 1\r\n        FinalMinimumWaste = 4 -height\r\n        return[counterArray ,FinalMinimumWaste ]\r\n    }\r\n    for(let GrassWidth = 2 ; GrassWidth <= 4 ; GrassWidth++){\r\n        counterArray[GrassWidth - 2] = Math.floor(height / GrassWidth) - 1\r\n        remain = GrassWidth + (height % GrassWidth)\r\n        TempminimumWaste = GrassWidth - (remain % GrassWidth)\r\n        TempMinimumWidth = GrassWidth\r\n        for(let SecondWidth = 2 ; SecondWidth <= 4 ; SecondWidth++){\r\n            if(remain !== GrassWidth && SecondWidth >= remain){\r\n                if(Math.abs(SecondWidth - remain) < Math.abs(TempMinimumWidth - remain)){\r\n                    TempMinimumWidth = SecondWidth\r\n                    TempminimumWaste =  Math.abs(SecondWidth - remain)\r\n                }\r\n            }\r\n        }\r\n        counterArray[TempMinimumWidth - 2] += 1\r\n        if(remain > TempMinimumWidth){\r\n            counterArray[TempMinimumWidth - 2] += 1\r\n        }\r\n        if(Math.abs((height - ((counterArray[0] * 2) +(counterArray[1] * 3) + (counterArray[2] * 4)))) < FinalMinimumWaste){\r\n            FinalMinimumWaste = Math.abs((height - ((counterArray[0] * 2) +(counterArray[1] * 3) + (counterArray[2] * 4))))\r\n            FinalCounterArray = [...counterArray]\r\n        }\r\n        counterArray = [0,0,0]\r\n    }\r\n    FinalCounterArray = MinimizeStrips(FinalCounterArray)\r\n    return [FinalCounterArray ,FinalMinimumWaste ]\r\n}\r\n\r\nexport default RectangleSplitter","\r\nconst LineLength = (x,y,x1,y1) => {\r\n    //return the line length\r\n    return(Math.sqrt(Math.pow((x-x1),2) + Math.pow((y-y1),2)))\r\n}\r\n\r\nconst RectangleMeasures = (Points) => {\r\n    // return the height and width of the rectangle and return which measure controll left and right direction and which one controlls the up down direction\r\n    let upDownMeasure \r\n    let leftRightMeasure\r\n    // if the diffrence between x's smaller the diffrence between Y's its more vertical else more horizontal\r\n    if(Math.abs(Points[0][0] -  Points[1][0]) <= Math.abs(Points[0][1] -  Points[1][1])){\r\n        upDownMeasure = LineLength(Points[0][0] ,Points[0][1] , Points[1][0] , Points[1][1])\r\n        leftRightMeasure = LineLength(Points[1][0] ,Points[1][1] , Points[2][0] , Points[2][1])\r\n      \r\n    }\r\n    else{\r\n        upDownMeasure = LineLength(Points[1][0] ,Points[1][1] , Points[2][0] , Points[2][1])\r\n        leftRightMeasure = LineLength(Points[0][0] ,Points[0][1] , Points[1][0] , Points[1][1])\r\n    }\r\n    if(upDownMeasure % 1 > 0 && upDownMeasure % 1 < 0.05){\r\n        upDownMeasure = Math.floor(upDownMeasure)\r\n    }\r\n    if(leftRightMeasure % 1 < 0 && leftRightMeasure % 1 < 0.05){\r\n        leftRightMeasure = Math.floor(leftRightMeasure)\r\n    } \r\n    return [upDownMeasure , leftRightMeasure]\r\n}\r\n\r\nexport default RectangleMeasures","import ShapePoints from \"../Algorithm/DotsSpreading\"\r\nimport GetLongestLine from \"./LongestLinePossible\"\r\nimport ShapeSplitter from './ShapeSplitter'\r\nimport {\r\n    smallestSurroundingRectangleByWidth,\r\n    smallestSurroundingRectangleByArea,\r\n  } from \"geojson-minimum-bounding-rectangle\";\r\nimport * as turf from 'turf/turf'\r\nimport smallestSurroundingRectangleByarea from './SmallestRectangle'\r\nimport GetLongestStraightLine from './LongestStraightLinePossible'\r\nimport Rectangle from \"../Components/Konva/Rectangle\";\r\nimport RectangleSplitter from './RectangleSplitter'\r\nimport RectangleMeasures from './RectangleMeasures'\r\n\r\nconst insertPointAtIndex = (point , Points , index) => {\r\n    let copyPoints = []\r\n    for(let i = 0 ; i< Points.length ; i++){\r\n        if(i === index){\r\n            copyPoints.push(point)\r\n        }\r\n        copyPoints.push(Points[i])\r\n    }\r\n    if(index === Points.length){\r\n        copyPoints.push(point)\r\n    }\r\n    return copyPoints\r\n}\r\n\r\nconst checkBetterWasteDirection = (horizontalArray , verticalArray) => {\r\n    let SumHorizontal = 0\r\n    let SumVertical = 0\r\n    for(let i = 0 ; i< horizontalArray.length ; i++){\r\n        for(let j =0 ; j< horizontalArray[i].length ; j++){\r\n        SumHorizontal += horizontalArray[i][j][1]\r\n        SumVertical += verticalArray[i][j][1]\r\n        }\r\n    }\r\n    if(SumHorizontal <= SumVertical){\r\n        return 'horizontal'\r\n    }\r\n    else{\r\n        return 'vertical'\r\n    }\r\n}\r\n\r\nconst checkBetterAttachmentsDirection = (horizontalArray , verticalArray) => {\r\n  \r\n    let numOfStripesHorizontal = 0\r\n    let numOfStripesVertical = 0\r\n    for(let i = 0 ; i< horizontalArray.length ; i++){\r\n        for(let j =0 ; j< horizontalArray[i].length ; j++){\r\n        numOfStripesHorizontal += (horizontalArray[i][j][0][0] + horizontalArray[i][j][0][1] + horizontalArray[i][j][0][2])\r\n        numOfStripesVertical += (verticalArray[i][j][0][0] + verticalArray[i][j][0][1] + verticalArray[i][j][0][2])\r\n        }\r\n    }\r\n    if(numOfStripesHorizontal < numOfStripesVertical){\r\n        return 'horizontal'\r\n    }\r\n    else{\r\n        if(numOfStripesHorizontal > numOfStripesVertical){\r\n            return 'vertical'\r\n        }\r\n        else{\r\n            return checkBetterWasteDirection(horizontalArray , verticalArray)\r\n        }\r\n    }\r\n}\r\n\r\nconst indexOfPoint = (point , Points) => {\r\n    // returns the index of certain point\r\n    for(let index = 0 ; index < Points.length ; index++){\r\n        if(Points[index][0] === point[0] && Points[index][1] === point[1]){\r\n            return index\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nconst calcPolygonArea = (vertices) => {\r\n    //calculating the initial polygon area and the total waste\r\n    var total = 0;\r\n\r\n    for (var i = 0, l = vertices.length; i < l; i++) {\r\n      var addX = vertices[i][0];\r\n      var addY = vertices[i == vertices.length - 1 ? 0 : i + 1][1];\r\n      var subX = vertices[i == vertices.length - 1 ? 0 : i + 1][0];\r\n      var subY = vertices[i][1];\r\n\r\n      total += (addX * addY * 0.5);\r\n      total -= (subX * subY * 0.5);\r\n    }\r\n  \r\n    return Math.abs(total);\r\n}\r\n\r\nconst algorithm = (Shapes) => {\r\n    let ResultArray = []\r\n    let MinimumWasteResultArray = []\r\n    let MinimumAttachmentsResultArray = []\r\n    let MinimumWasteUpDown = []\r\n    let MinimumWasteRightLeft = []\r\n    for(let shape = 0 ; shape < Shapes.length ; shape++){\r\n        MinimumWasteResultArray.push(algorithmForOneShape(Shapes[shape] , 'minimumWaste'))\r\n    }\r\n    ResultArray.push(MinimumWasteResultArray)\r\n    for(let shape = 0 ; shape < Shapes.length ; shape++){\r\n        MinimumAttachmentsResultArray.push(algorithmForOneShape(Shapes[shape] , 'minimumAttachments'))\r\n    }\r\n    ResultArray.push(MinimumAttachmentsResultArray)\r\n    for(let shape = 0 ; shape < Shapes.length ; shape++){\r\n        MinimumWasteUpDown.push(algorithmForOneShape(Shapes[shape] , 'sameDirection' , 'up'))\r\n        MinimumWasteRightLeft.push(algorithmForOneShape(Shapes[shape] , 'sameDirection' , 'left'))\r\n    }\r\n    //checking which is better leftRight or Updown in terms of waste\r\n    let direction = checkBetterWasteDirection(MinimumWasteRightLeft ,MinimumWasteUpDown)\r\n    if(direction === 'horizontal'){\r\n        ResultArray.push(MinimumWasteRightLeft)\r\n    }\r\n    else{\r\n        ResultArray.push(MinimumWasteUpDown)\r\n    }\r\n     //checking which is better leftRight or Updown in terms of attachments\r\n    direction = checkBetterAttachmentsDirection(MinimumWasteRightLeft ,MinimumWasteUpDown)\r\n    if(direction === 'horizontal'){\r\n        ResultArray.push(MinimumWasteRightLeft)\r\n    }\r\n    else{\r\n        ResultArray.push(MinimumWasteUpDown)\r\n    }\r\n    return ResultArray\r\n}\r\n\r\n\r\nconst algorithmForOneShape = (Points , calcType , direction) => {\r\n    let RectengularArray = []\r\n    let ShapesArray = [Points]\r\n    let SplitedArray = []\r\n    let LongestPath = 0\r\n    while (ShapesArray.length > 0) {\r\n        for(let Shape = 0 ; Shape < ShapesArray.length ; Shape++){            \r\n            // if the given shape is already 4 vertexes or less skip on the algorithm stages\r\n            if(ShapesArray[Shape].length <= 4){\r\n                RectengularArray.push(ShapesArray[Shape])\r\n            }\r\n            else{\r\n                //gets the longest Path that is available between two vertexes\r\n                LongestPath = GetLongestStraightLine(ShapesArray[Shape])\r\n                if(LongestPath.length === 0){\r\n                    RectengularArray.push(ShapesArray[Shape])\r\n                }\r\n                else{\r\n                        // insert the cross point of the longest line to the shape\r\n                        ShapesArray[Shape] = insertPointAtIndex(LongestPath[2] ,  ShapesArray[Shape] , LongestPath[3])\r\n                                \r\n                        // split the shape into two shapes according to the longest line\r\n                        let Shapes\r\n                        if(indexOfPoint([LongestPath[0],LongestPath[1]] ,ShapesArray[Shape]) < indexOfPoint(LongestPath[2] ,ShapesArray[Shape])){\r\n                            Shapes = ShapeSplitter([LongestPath[0],LongestPath[1]] ,LongestPath[2] , ShapesArray[Shape])\r\n                        }\r\n                        else{\r\n                            Shapes = ShapeSplitter(LongestPath[2] ,[LongestPath[0],LongestPath[1]] , ShapesArray[Shape])\r\n                        }\r\n                        \r\n\r\n                        //if one of the splitted shapes is below 4 point than push it to the rectengular shapes array else send it to another round\r\n                        if(Shapes[0].length <= 4){\r\n                            RectengularArray.push(Shapes[0])\r\n                        }\r\n                        else{\r\n                            SplitedArray.push(Shapes[0])\r\n                        }\r\n                        if(Shapes[1].length <= 4){\r\n                            RectengularArray.push(Shapes[1])\r\n                        }\r\n                        else{\r\n                            SplitedArray.push(Shapes[1])\r\n                        }\r\n                }\r\n               \r\n            }\r\n           \r\n        }\r\n        ShapesArray = [...SplitedArray]\r\n        SplitedArray = []\r\n    }   \r\n\r\n    //check if its better to just surround it with one Rectangle\r\n    if(RectengularArray.length >= 5){\r\n        RectengularArray = [Points]\r\n    }\r\n\r\n    //will include all the minimum waste Layouts\r\n    let MinimumWasteArray = []\r\n    for(let FinalShape = 0 ;FinalShape < RectengularArray.length ; FinalShape++){\r\n        //getting the surrounding rectangle\r\n        let Rectangle = smallestSurroundingRectangleByarea(RectengularArray[FinalShape])\r\n        //calculate from the rectangle points the height and width\r\n        let Measures = RectangleMeasures(Rectangle['geometry']['coordinates'][0])\r\n        //the first cell will be count array of grass rolls \r\n        let MinimumWasteWidth = RectangleSplitter(Measures[0] , Measures[1])\r\n        let MinimumWasteHeight = RectangleSplitter(Measures[1] , Measures[0])\r\n        console.log(Measures ,'Measures' )\r\n        let newMeasures = roundUp([...Measures])\r\n        console.log(newMeasures ,'Measures2' )\r\n       // console.log(Measures[0] , Measures[1] , MinimumWasteWidth , MinimumWasteHeight , 'minimums')\r\n        //decides if calculating according height or width\r\n        if(calcType === 'minimumWaste'){\r\n            if(MinimumWasteWidth[1] * newMeasures[0] < MinimumWasteHeight[1] * newMeasures[1])\r\n            {\r\n                // how long of each grass length\r\n                MinimumWasteWidth.push(Measures[0])\r\n                MinimumWasteArray.push(MinimumWasteWidth)\r\n             \r\n            }\r\n            else{\r\n                if(MinimumWasteWidth[1] * newMeasures[0] === MinimumWasteHeight[1] * newMeasures[1]){\r\n                    if(newMeasures[1] <= newMeasures[0]){\r\n                        MinimumWasteWidth.push(Measures[0])\r\n                        MinimumWasteArray.push(MinimumWasteWidth)\r\n                        \r\n                    }\r\n                    else\r\n                    {\r\n                        MinimumWasteHeight.push(Measures[1])\r\n                        MinimumWasteArray.push(MinimumWasteHeight)\r\n                                  \r\n                    }\r\n                }\r\n                else{\r\n                    // how long of each grass length\r\n                    MinimumWasteHeight.push(Measures[1])\r\n                    MinimumWasteArray.push(MinimumWasteHeight)\r\n                    \r\n                }\r\n                \r\n            }\r\n        }\r\n        if(calcType === 'minimumAttachments'){\r\n            let numOfStripsWidth = MinimumWasteWidth[0][0] + MinimumWasteWidth[0][1] + MinimumWasteWidth[0][2]\r\n            let numOfStripsHeight = MinimumWasteHeight[0][0] + MinimumWasteHeight[0][1] + MinimumWasteHeight[0][2]\r\n            if(numOfStripsWidth < numOfStripsHeight){\r\n                MinimumWasteWidth.push(Measures[0])\r\n                MinimumWasteArray.push(MinimumWasteWidth)\r\n               \r\n            }\r\n            else{\r\n                if(numOfStripsWidth > numOfStripsHeight){\r\n                    MinimumWasteHeight.push(Measures[1])\r\n                    MinimumWasteArray.push(MinimumWasteHeight)\r\n                }\r\n                else{\r\n                    if(MinimumWasteWidth[1] > MinimumWasteHeight[1]){\r\n                        MinimumWasteHeight.push(Measures[1])\r\n                        MinimumWasteArray.push(MinimumWasteHeight)\r\n                    }\r\n                    else{\r\n                        MinimumWasteWidth.push(Measures[0])\r\n                        MinimumWasteArray.push(MinimumWasteWidth)\r\n                    }\r\n                }\r\n                \r\n            }\r\n        }\r\n        if(calcType === 'sameDirection'){\r\n           \r\n            if(direction === 'up'){\r\n           \r\n                MinimumWasteWidth.push(Measures[0])\r\n                MinimumWasteArray.push(MinimumWasteWidth)\r\n                \r\n            }\r\n            else{\r\n               \r\n                MinimumWasteHeight.push(Measures[1])\r\n                MinimumWasteArray.push(MinimumWasteHeight)\r\n                \r\n            }\r\n        }\r\n        // MinimumWasteArray[FinalShape][2] = Math.round(MinimumWasteArray[FinalShape][2] *2)/2;\r\n       \r\n        let initialPolygonArea = calcPolygonArea(RectengularArray[FinalShape])\r\n        let RectangleArea = calcPolygonArea(Rectangle['geometry']['coordinates'][0])\r\n        let striperemain = MinimumWasteArray[FinalShape][1]\r\n        let minimumMeasure = MinimumWasteArray[FinalShape][2] === Measures[0] ? Measures[1] : Measures[0]  \r\n        MinimumWasteArray[FinalShape][1] = (RectangleArea - initialPolygonArea) + (MinimumWasteArray[FinalShape][1] * roundUpNumber(MinimumWasteArray[FinalShape][2])) + (minimumMeasure * (roundUpNumber(MinimumWasteArray[FinalShape][2]) - MinimumWasteArray[FinalShape][2]))\r\n        MinimumWasteArray[FinalShape].push(reOrder(Rectangle['geometry']['coordinates'][0]))\r\n        MinimumWasteArray[FinalShape].push(RectengularArray[FinalShape])\r\n        MinimumWasteArray[FinalShape].push(striperemain)\r\n        MinimumWasteArray[FinalShape].push(roundUpNumber(MinimumWasteArray[FinalShape][2]) === Measures[0] ? 'down' : 'right')\r\n        //pushing measurement with the 0.5 round up\r\n        MinimumWasteArray[FinalShape].push(roundUpNumber(MinimumWasteArray[FinalShape][2]))\r\n    }\r\n    return MinimumWasteArray\r\n}\r\n\r\n\r\nconst roundUp = (Measures) => {\r\n    let newMeasures = []\r\n    if(Measures[0]%1 < 0.5 && Measures[0]%1 > 0){\r\n        Measures[0] += 0.5 - Measures[0]%1\r\n    }\r\n    else{\r\n        if(Measures[0]%1 > 0.5){\r\n            Measures[0] += 1 - Measures[0]%1\r\n        }\r\n    }\r\n    newMeasures.push(Measures[0])\r\n    if(Measures[1]%1 < 0.5 && Measures[1]%1 > 0){\r\n        Measures[1] += 0.5 - Measures[1]%1\r\n    }\r\n    else{\r\n        if(Measures[1]%1 > 0.5){\r\n            Measures[1] += 1 - Measures[1]%1\r\n        }\r\n    }\r\n    newMeasures.push(Measures[1])\r\n    return newMeasures\r\n}\r\n\r\nconst roundUpNumber = (number) => {\r\n    \r\n    if(number%1 < 0.5 && number%1 > 0){\r\n        number += 0.5 - number%1\r\n    }\r\n    else{\r\n        if(number%1 > 0.5){\r\n            number += 1 - number%1\r\n        }\r\n    }\r\n    return number\r\n    \r\n}\r\n\r\nconst reOrder = (Rectangle) => {\r\n    //ordering the rectangle so the first point will be the upperleft\r\n    //the upperleft will always be with the smallest x and (because of the upsidedown of the stage) the biggest y\r\n    // we can just reverse the order \r\n    let orderedRectangle = []\r\n    for(let vertex = Rectangle.length-2 ; vertex >= 0; vertex--){\r\n        orderedRectangle.push(Rectangle[vertex])\r\n    }\r\n    return orderedRectangle\r\n}\r\n\r\nexport default algorithm","\r\n\r\nconst roundingUp = (Points) => {\r\n     //get an array of points and return the same array in the right proportion\r\n     let RoundedPointsArray = [...Points]\r\n     for(let point =0 ; point < RoundedPointsArray.length ; point++){\r\n        let roundingUpX = RoundedPointsArray[point][0]\r\n        let roundingUpY = RoundedPointsArray[point][1]\r\n        for(let j = 0 ; j < RoundedPointsArray.length ; j++){\r\n            if(roundingUpX - RoundedPointsArray[j][0] > 0 && roundingUpX - RoundedPointsArray[j][0] < 20){\r\n                RoundedPointsArray[j][0] = roundingUpX\r\n            }\r\n            if(roundingUpY - RoundedPointsArray[j][1] > 0 && roundingUpY - RoundedPointsArray[j][1] < 20){\r\n                RoundedPointsArray[j][1] = roundingUpY\r\n            }\r\n        }\r\n     }\r\n     return RoundedPointsArray\r\n}\r\n\r\n\r\nconst TransformintoProportion = (Points , proportion , height) => {\r\n    //get an array of points and return the same array in the right proportion\r\n    let TranformedPointsArray = []\r\n    for(let point =0 ; point < Points.length ; point++){\r\n        let TransformedPoint = [Points[point][0]/proportion , (height- Points[point][1])/proportion]\r\n        TranformedPointsArray.push(TransformedPoint)\r\n    }\r\n    return TranformedPointsArray\r\n}\r\n\r\nconst FindRectPoints = (x,y,height,width) => {\r\n    //this funtcion gets the topLeft corner of a rectangle his width and height and return his points\r\n    let RectanglePoints = [[x,y+height] , [x,y] , [x+width, y] , [x+width,y+height]]\r\n    return RectanglePoints\r\n}\r\n\r\nconst RectangleHandler = (Rectangles , stageHeight , proportion) => {\r\n    let OrderedRects = []\r\n    for (let rect = 0 ;rect < Rectangles.length ; rect++){\r\n        let RectPoints = FindRectPoints(Rectangles[rect].x ,Rectangles[rect].y , Rectangles[rect].height, Rectangles[rect].width)\r\n        RectPoints = TransformintoProportion(RectPoints , proportion , stageHeight)\r\n        OrderedRects.push(RectPoints)\r\n    }\r\n    return OrderedRects\r\n}\r\n\r\nconst PolygonHandler = (Polygons , stageHeight , proportion) => {\r\n    let OrderedPolygons = []\r\n    for(let polygon = 0 ; polygon < Polygons.length ; polygon++){\r\n        let polygonPoints = Polygons[polygon][\"points\"]\r\n        polygonPoints = roundingUp(polygonPoints)\r\n        polygonPoints = TransformintoProportion(polygonPoints , proportion , stageHeight)\r\n        OrderedPolygons.push(polygonPoints)\r\n    }\r\n    return OrderedPolygons\r\n}\r\n\r\nconst CircleHandler = (Circles , stageHeight , proportion) => {\r\n    let OrderedCircles = []\r\n    for(let Circle = 0 ; Circle < Circles.length ; Circle++){\r\n        let x = Circles[Circle].x \r\n        let y = Circles[Circle].y \r\n        let radius = Circles[Circle].radius \r\n        let CircleRectPoints = FindRectPoints(x-(radius/2) , y-(radius/2) , radius , radius)\r\n        CircleRectPoints = TransformintoProportion(CircleRectPoints , proportion , stageHeight)\r\n        OrderedCircles.push(CircleRectPoints)\r\n    }\r\n    return OrderedCircles\r\n}\r\n\r\nconst ProportionController = {\r\n    TransformintoProportion,\r\n    FindRectPoints,\r\n    RectangleHandler,\r\n    PolygonHandler,\r\n    CircleHandler\r\n}\r\n\r\nexport default ProportionController","import React from 'react';\r\nimport {useEffect , useState} from 'react'\r\nimport Grid from '@material-ui/core/Grid'\r\nimport Divider from '@material-ui/core/Divider'\r\nimport ExpansionPanel from '@material-ui/core/ExpansionPanel'\r\nimport ExpansionPanelContent from '@material-ui/core/ExpansionPanelDetails'\r\nimport ExpansionPanelSummary from '@material-ui/core/ExpansionPanelSummary'\r\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore'\r\nimport Fab from '@material-ui/core/Fab';\r\nimport calc from '@material-ui/icons/'\r\nimport CalcWindow from './CalcWindow/CalcWindow';\r\nimport KonvaContainer from './Konva/KonvaContainer'\r\nimport DrawToolBar from './Konva/DrawToolBar'\r\nimport ShapePoints from '../Algorithm/DotsSpreading';\r\nimport algorithm from '../Algorithm/Algorithm'\r\nimport { connect , dispatch } from \"react-redux\"\r\nimport ProportionController from '../Algorithm/ShapesProportions'\r\nimport Button from '@material-ui/core/Button'\r\n\r\nconst Container = (props) => {\r\n\r\n    const [openCalc , setopenCalc] = useState(false)\r\n\r\n    const handleClose = () =>{\r\n        setopenCalc(false)\r\n    }\r\n\r\n    const handleOpen = () => {\r\n        // tryLongestPath([[4,6],[4,12],[7,12],[7,16],[27,16],[27,1],[20,6]])\r\n        // tryLongestPath([[3,3],[3,11],[20,11],[20,3],[11,3],[11,6],[14,6],[14,9],[7,9],[7,3]])\r\n        //tryLongestPath([[4,4],[4,10],[12,10],[12,12.1],[18.4,12.1],[18.4,4],])\r\n        //algorithm([ [[4,4],[4,24] ,[15.5,24],[15.5,4]] ])\r\n        let orderedRects = ProportionController.RectangleHandler(props.Rectangles , props.height , (30/props.proportion)*2) \r\n        let orderedPolygons = ProportionController.PolygonHandler(props.Polygons , props.height ,  (30/props.proportion)*2)\r\n        let orderedCircles = ProportionController.CircleHandler(props.Circles , props.height ,  (30/props.proportion)*2)\r\n        let algorithmResult\r\n        try{\r\n            algorithmResult = algorithm([...orderedRects, ...orderedCircles, ...orderedPolygons])\r\n        }\r\n        catch(e){\r\n            alert('cant handle it yet')\r\n        }\r\n        //algorithmResult = reversePoints(algorithmResult)\r\n        console.log(algorithmResult)\r\n        props.ChagneResultArray(algorithmResult)\r\n        setopenCalc(true)  \r\n    }\r\n\r\n    return(\r\n        <Grid container spacing = {0} style = {{direction : 'rtl'}}>\r\n            <Grid item xl = {12}  xs = {12}>\r\n                <p style = {{direction : 'rtl' , fontSize : '24px' , marginRight : '20px'}}>  </p>\r\n                <Divider variant = 'middle' style = {{width : '15%' , position : 'absolute' , right: '0' ,marginTop : '-20px'}}></Divider>\r\n            </Grid>\r\n            <Grid item xl = {1.5} xs = {1.5}>\r\n                <ExpansionPanel style = {{width : '100%',  marginRight : '20px'}}>\r\n                    <ExpansionPanelSummary expandIcon = {<ExpandMoreIcon/>}>\r\n                        \r\n                    </ExpansionPanelSummary>\r\n                    <ExpansionPanelContent>\r\n                        yay\r\n                    </ExpansionPanelContent>\r\n                </ExpansionPanel>\r\n            </Grid>\r\n            <Grid item xl = {12} xs = {12}>\r\n            </Grid>\r\n            <Grid item xl = {1} md  = {2} xs = {3} style ={ {marginTop:'15px' , marginRight : '15px'}}>\r\n                <Fab onClick = {handleOpen} variant = 'extended' style = {{width : '100%', color :'black' , backgroundColor : '#AFD5AA'}}>\r\n                    <p style = {{color : 'white'}}></p>                   \r\n                </Fab>\r\n            </Grid>\r\n            <Grid xl = {11} xs = {11}>\r\n                <div style = {{border : '2px solid grey', borderRadius : '5px' , height : '68vh' , width: '97vw' , marginRight : '20px' , marginTop : '20px'}}>\r\n                    <div style = {{height : '13%'}}>\r\n                        <DrawToolBar></DrawToolBar>\r\n                    </div>\r\n                    <div id = \"parent\" style = {{height : '83%' , width: '97vw' , marginTop : '20px'}}>\r\n                        <KonvaContainer></KonvaContainer>\r\n                    </div>\r\n                    \r\n                </div>\r\n            </Grid>\r\n            <Grid xl = {12} xs = {12}  style = {{height : '90%', width : '90%'}}>\r\n                <CalcWindow open = {openCalc} close = {handleClose}></CalcWindow>\r\n            </Grid>\r\n        </Grid>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        mode : state.konva.mode,\r\n        stage : state.konva.stage,\r\n        height : state.konva.height,\r\n        Polygons : state.konva.Polygons,\r\n        Rectangles : state.konva.Rectangles,\r\n        Circles : state.konva.Circles,\r\n        proportion : state.konva.proportion\r\n    }\r\n}\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        ChagneResultArray: (newResult) => dispatch({type : 'ChagneResultArray' , newResult : newResult}),\r\n    }\r\n}\r\n\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Container)\r\n\r\n","\r\nimport './App.css';\r\nimport Container from './Components/container'\r\nimport KonvaArch from './Components/Konva/konvaArch'\r\nfunction App() {\r\n  return (\r\n    // <KonvaArch></KonvaArch>\r\n    <Container></Container>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { SatelliteSharp } from \"@material-ui/icons\"\r\n\r\n\r\nconst initial_state = {\r\n    mode : 'Polygon',\r\n    stage : null,\r\n    height : 0,\r\n    Polygons : [],\r\n    Rectangles : [],\r\n    Circles : [],\r\n    Windowstage : null,\r\n    AlgorithmResult:[],\r\n    points : [],\r\n    proportion : 1,\r\n    accuracy : 10,\r\n    stateStack : []\r\n}\r\n\r\n\r\n\r\nconst konvaReducer = (state = initial_state , action) => {\r\n    switch (action.type){\r\n         \r\n        case 'ChangeMode' : \r\n            return {\r\n                ...state,\r\n                mode : action.newMode\r\n            }   \r\n        case 'ChangeStage' : \r\n            return {\r\n                ...state,\r\n                stage : action.newStage\r\n            }  \r\n            \r\n        case 'ChangeStageWindow' : \r\n            return {\r\n                ...state,\r\n                Windowstage : action.newWindowstage\r\n            }  \r\n        case 'UpdatePolygons' : \r\n            return {\r\n                ...state,\r\n                Polygons : action.newPolygons\r\n            }   \r\n        case 'UpdateRectangles' : \r\n            return {\r\n                ...state,\r\n                Rectangles : action.newRectangles\r\n            }   \r\n        case 'UpdateCircles' : \r\n            return {\r\n                ...state,\r\n                Circles : action.newCircles\r\n            }   \r\n        case 'ChagneResultArray': \r\n            return {\r\n                ...state,\r\n                AlgorithmResult : action.newResult\r\n            }  \r\n        case 'AddPoint':\r\n            let newPoints = [...state.points , action.newPoint]\r\n            return{\r\n                ...state,\r\n                points : newPoints\r\n            }\r\n        case 'emptyPoints':       \r\n            return{\r\n                ...state,\r\n                points : []\r\n            }\r\n        case 'actionTrigger' : \r\n            let newState ={...state}\r\n            delete newState['stateStack']\r\n            let CopystateStack = [...state.stateStack , newState]\r\n            return{\r\n                ...state,\r\n                stateStack : CopystateStack\r\n            }\r\n        case 'Undo' : \r\n            let lastState \r\n            \r\n            if(state.stateStack.length <= 1){\r\n                lastState =  { \r\n                    mode : 'Polygon',\r\n                    stage : null,\r\n                    height : 0,\r\n                    Polygons : [],\r\n                    Rectangles : [],\r\n                    Circles : [],\r\n                    Windowstage : null,\r\n                    AlgorithmResult:[],\r\n                    points : [],\r\n                    proportion : 1,\r\n                    accuracy : 10,\r\n                    stateStack : []\r\n                }\r\n            }\r\n            else{\r\n                lastState = {...state.stateStack[state.stateStack.length -2]}\r\n                lastState['stateStack'] = state.stateStack\r\n                lastState['stateStack'].splice( lastState['stateStack'].length-1 , 1)\r\n                \r\n            }      \r\n            console.log(lastState, 'laststate')\r\n            return{\r\n                ...lastState                \r\n            }\r\n        case 'Reset':\r\n            return{\r\n                mode : 'Polygon',\r\n                stage : null,\r\n                height : 0,\r\n                Polygons : [],\r\n                Rectangles : [],\r\n                Circles : [],\r\n                Windowstage : null,\r\n                AlgorithmResult:[],\r\n                points : [],\r\n                proportion : 1,\r\n                accuracy : 10,\r\n                stateStack : []\r\n            }\r\n        case 'ChangeProportion':\r\n            return{\r\n               ...state,\r\n               proportion : action.newProportion\r\n            }\r\n        case 'ChangeAccuracy':\r\n            return{\r\n                ...state,\r\n                accuracy : action.newAccuracy\r\n            }\r\n    }\r\n    return state\r\n}\r\n\r\n\r\nexport default konvaReducer","import { combineReducers } from 'redux';\r\n\r\n\r\nimport konvaReducer from './konvaReducer';\r\n\r\n\r\nconst rootReducer = combineReducers({\r\n    konva : konvaReducer,\r\n});\r\n\r\nexport default rootReducer;","import { createStore } from 'redux';\r\n\r\nimport rootreducer from './rootreducer';\r\n\r\n\r\n    const store = createStore(rootreducer);\r\n\r\n\r\n    export default store;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\n\n\nReactDOM.render(\n  <Provider store = {store}>\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n  </Provider>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}